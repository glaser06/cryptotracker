//
//  ShowPortfolioViewController.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Charts
import Hero


protocol ShowPortfolioDisplayLogic: class
{
    func displayPortfolio(viewModel: ShowPortfolio.FetchPortfolio.ViewModel)
    func displayCharts(viewModel: ShowPortfolio.FetchAssetCharts.ViewModel)
    func displayPortfolioChart(viewModel: ShowPortfolio.FetchPortFolioChart.ViewModel)
    func stopLoading()
}

class ShowPortfolioViewController: UIViewController, ShowPortfolioDisplayLogic
{
    var interactor: ShowPortfolioBusinessLogic?
    var router: (NSObjectProtocol & ShowPortfolioRoutingLogic & ShowPortfolioDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = ShowPortfolioInteractor()
        let presenter = ShowPortfolioPresenter()
        let router = ShowPortfolioRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    var assets: [ShowPortfolio.FetchPortfolio.ViewModel.DisplayableAsset] = []
    var watchlist: [ShowPortfolio.FetchPortfolio.ViewModel.DisplayableCoin] = []
    var assetsOnDisplay: [ShowPortfolio.FetchPortfolio.ViewModel.DisplayableAsset] = []
//    var allColors: [NSUIColor] = ChartColorTemplates.joyful() + ChartColorTemplates.liberty() + ChartColorTemplates.pastel() + ChartColorTemplates.vordiplom() + ChartColorTemplates.material() + ChartColorTemplates.colorful()
    var colorsForAssets: [NSUIColor] = []
    var anglesForAssets: [String: CGFloat] = [:]
    var chartData: [String:  [String:  [(Int, Double, Double, Double, Double, Double)]]] = [:]
    
    var canUpdateCharts: Bool = true
    
    var refresher: UIRefreshControl!
    
    var isLoading: Bool = false
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        panGR = UIPanGestureRecognizer(target: self, action: #selector(handlePan(gestureRecognizer:)))
        
        view.addGestureRecognizer(panGR)

//        let p = PortfolioWorker.sharedInstance
        if #available(iOS 11.0, *) {
            self.scrollView.contentInsetAdjustmentBehavior = .never
        } else {
            // Fallback on earlier versions
            self.automaticallyAdjustsScrollViewInsets = false
        }
        self.view.bringSubview(toFront: self.menuView)
        self.lineChart.delegate = self
        self.navBarView.heroModifiers = [.fade]
        self.navBarView.snp.makeConstraints { (make) in
            make.height.equalTo(56)
//            make.width.equalTo(self.view.frame.width - 95)
        }
//        let tap = UITapGestureRecognizer(target: self, action: #selector(close))
//        self.navBarView.addGestureRecognizer(tap)

        self.navigationController?.navigationBar.layoutIfNeeded()
        

        

        navigationController?.heroNavigationAnimationType = .none
        navigationController?.clearShadow()
        navigationController?.interactivePopGestureRecognizer?.delegate = self
//        self.view.heroModifiers = [.fade]
//        navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        setupRefresher()
        setupAssetTable()
        setupMenu()
        self.pieChartView.heroID = "pieChart0"
        self.menuView.layer.shadowOffset = CGSize(width: 0.0, height: 1.0)
        self.pieChartUpdate()
//        self.fetchCharts(true)
//        DispatchQueue.global(qos: .userInteractive).async {
//
//        }
        
        
        
        
        
        
        
        
    }
    override func viewWillDisappear(_ animated: Bool) {
//        navigationController?.interactivePopGestureRecognizer?.isEnabled = true

    }
    
    override func viewWillAppear(_ animated: Bool) {
//        navigationController?.heroNavigationAnimationType = .none
        
//        navigationController?.heroNavigationAnimationType = .auto
        navigationController?.interactivePopGestureRecognizer?.delegate = self

//        navigationController?.interactivePopGestureRecognizer?.isEnabled = false
//        navigationController?.interactivePopGestureRecognizer?.delegate = self
        
        
        
    }
    override func viewDidAppear(_ animated: Bool) {
        self.reload()
        //        lineChartUpdate()
        

//        self.pieChartUpdate()
//        self.fetchCharts()
        
        navigationController?.heroNavigationAnimationType = .selectBy(presenting:.push(direction: .left), dismissing:.pull(direction: .right))
    }
    
    @IBOutlet weak var menuBarButton: UIBarButtonItem!
    
    
    
    func setupRefresher() {
        self.refresher = UIRefreshControl()
        self.refresher.addTarget(self, action: #selector(reload), for: .valueChanged)
        self.scrollView.refreshControl = self.refresher
        self.scrollView.isScrollEnabled = true
        self.scrollView.alwaysBounceVertical = true
        self.refresher.didMoveToSuperview()
    }
    func setupMenu() {
//        self.menuView.isHidden = false
//        self.navigationItem.leftBarButtonItem = UIBarButtonItem(customView: self.menuView)
//        self.navigationController?.navigationItem.leftBarButtonItem = UIBarButtonItem(customView: self.menuView)
//        var view = menuBarButton.customView!
//        view.frame = CGRect(x: view.frame.origin.x, y: view.frame.origin.y, width: 44.0, height: 44.0)
//        
//        view.layer.cornerRadius = 22.0
//        menuBarButton.customView = view
//        self.view.setNeedsLayout()
//        self.view.layoutIfNeeded()
        
    }
    func drawShadow(view: UIView) -> UIView {
//        if nil == view.layer.shad {
        let size = view.frame.size
        view.clipsToBounds = true
        let layer: CALayer = CALayer()
        layer.backgroundColor = UIColor.lightGray.cgColor
        layer.position = CGPoint(x: size.width / 2, y: -size.height / 2 + 0.5)
        layer.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height)
//        layer.bounds = CGRect(0, 0, size.width, size.height)
        layer.shadowColor = UIColor.darkGray.cgColor

        layer.shadowOffset = CGSize(width: 0.5, height: 0.5)
        layer.shadowOpacity = 0.1
        layer.shadowRadius = 1.0
//            view.shadowLayer = layer
    
        view.layer.addSublayer(layer)
        return view
//        }
    }
    
    
    func getAllCoins() {
        interactor?.fetchAllCoins {
            let p = PortfolioWorker.sharedInstance.portfolio
//            print(p)
            self.reload()
//            self.fetchCharts()
        }
    }
    
    func setupAssetTable() {
        assetTableView.tableFooterView = UIView()
        assetTableView.register(UINib(nibName: "AssetTableViewCell", bundle: nil), forCellReuseIdentifier: "AssetCell")
        assetTableView.register(UINib(nibName: "FiatAssetTableViewCell", bundle: nil), forCellReuseIdentifier: "FiatAssetCell")
        assetTableView.register(UINib(nibName: "WatchlistTableViewCell", bundle: nil), forCellReuseIdentifier: "WatchlistCell")
        assetTableView.register(UINib(nibName: "LoadingTableCell", bundle: nil), forCellReuseIdentifier: "LoadingCell")
        assetTableView.register(UINib(nibName: "EmptyTableViewCell", bundle: nil), forCellReuseIdentifier: "EmptyTableViewCell")
        
        assetTableView.rowHeight = UITableViewAutomaticDimension
        assetTableView.estimatedRowHeight = 200
    }
    
    // MARK: Do something
    
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var assetTableView: UITableView!
    @IBOutlet weak var transactionButton: UIButton!
    
    @IBOutlet weak var totalValueLabel: UILabel!
    @IBOutlet weak var chartValueLabel: UILabel!
    @IBOutlet weak var changeValueButton: UIButton!
    
    
    @IBOutlet weak var tableHeight: NSLayoutConstraint!
    
    @IBOutlet weak var totalGainsLabel: UILabel!
    @IBOutlet weak var returnLabel: UILabel!
    @IBOutlet weak var costLabel: UILabel!
    
    @IBOutlet weak var pieChartView: PieChartView!
    @IBOutlet weak var lineChart: LineChartView!
    
    @IBOutlet var assetSwitches: [UIButton]!
    @IBOutlet var selectorViews: [UIView]!
    
    @IBOutlet weak var menuView: UIView!
    
    @IBOutlet weak var searchBarButton: UIButton!
//    @IBOutlet weak var searchBar: UISearchBar!
//    @IBOutlet weak var rightBarView: UIView!
    @IBOutlet weak var navBarView: UIView!
    @IBOutlet weak var titleLabel: UILabel!
    
    var theBlue: UIColor {
        return self.selectorViews[0].backgroundColor!
    }
    var selectedAssets: Int = 1
    var panGR: UIPanGestureRecognizer!
    var isAnimating: Bool = false
    
    func handlePan(gestureRecognizer:UIPanGestureRecognizer) {
        let translation = panGR.translation(in: nil)
        var progress = translation.x / view.bounds.width / 2
        print(translation)
        print(progress)
        switch panGR.state {
        case .began:
            // begin the transition as normal
            
            if progress < -0.01 {
                self.tabBarController?.heroTabBarAnimationType = .slide(direction: .left)
                self.tabBarController?.selectedIndex = 1
                isAnimating = true
                Hero.shared.update(progress)
                Hero.shared.apply(modifiers: [.translate(x: translation.x, y: 0, z: 0)], to: self.view)
            } else if progress > 0.01{
//                self.tabBarController?.heroTabBarAnimationType = .slide(direction: .right)
//                self.tabBarController?.selectedIndex = 2
//                isAnimating = true
//                Hero.shared.update(progress)
//                Hero.shared.apply(modifiers: [.translate(x: translation.x, y: 0, z: 0)], to: self.view)
            }
            
        case .changed:
            // calculate the progress based on how far the user moved
            if !isAnimating {
                if progress < -0.01 {
                    self.tabBarController?.heroTabBarAnimationType = .slide(direction: .left)
                    self.tabBarController?.selectedIndex = 1
                    isAnimating = true
                } else if progress > 0.01{
//                    self.tabBarController?.heroTabBarAnimationType = .slide(direction: .right)
//                    self.tabBarController?.selectedIndex = 2
//                    isAnimating = true
                }
            }
            if isAnimating{
                if self.tabBarController?.selectedIndex == 1 {
                    if progress < 0 {
                        progress *= -1
                    } else {
                        progress = 0
                    }
                } else {
//                    if progress < 0 {
//                        progress = 0
//                    }
                }
            }
            
            
            //            let translation = panGR.translation(in: nil)
            //            let progress = translation.x / 2 / view.bounds.width
            
            Hero.shared.update(progress + 0.1)
//            Hero.shared.apply(modifiers: [.translate(x: translation.x, y: 0, z: 0)], to: self.view)
//            Hero.shared.apply(modifiers: [.position(translation)], to: self.view)
        //            Hero.shared.update(Double(progress))
        default:
            
            // end or cancel the transition based on the progress and user's touch velocity
            let r = progress + self.panGR.velocity(in: nil).x / self.view.bounds.width
            
            if progress + self.panGR.velocity(in: nil).x / self.view.bounds.width > 0.3 {
//                DispatchQueue.main.asyncAfter(deadline: .now() + 0.0, execute: {
//                    Hero.shared.finish()
//                })
            } else if progress + self.panGR.velocity(in: nil).x / self.view.bounds.width < -0.3 {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.0, execute: {
                    Hero.shared.finish()
                })
            } else {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.0, execute: {
                    Hero.shared.cancel()
                })
            }
            self.isAnimating = false
            
            
            
        }
    }
    
    @IBAction func reload() {
        
        fetchPortfolio()
        
        pieChartUpdate()
//        lineChartUpdate()
        fetchCharts()
        
    }
    
    func fetchPortfolio() {
        interactor?.fetchPortfolio(request: ShowPortfolio.FetchPortfolio.Request())
    }
    
    
    var lastChartUpdate: Date = Date(timeIntervalSinceNow: -240)
    func fetchCharts(_ force: Bool = false) {
        let now = Date()
        
        let a = now.minutes(from: lastChartUpdate)
        if a > 3 || force {
            lastChartUpdate = Date()
            self.isLoading = true

            interactor?.fetchAssetCharts(request: ShowPortfolio.FetchAssetCharts.Request())
            
        }
        
    }
    
    func displayPortfolio(viewModel: ShowPortfolio.FetchPortfolio.ViewModel) {
        
        
        
        self.assets = viewModel.assets
        self.watchlist = viewModel.watchlist
        self.pieChartUpdate()
//        self.lineChartUpdate()
        let tempButton = UIButton()
        tempButton.tag = self.selectedAssets
        if self.assets.count == 0 {
            tempButton.tag = 4
        }
        
        self.changeAssetsDisplayed(sender: tempButton)
        
        let price = viewModel.totalString
        self.totalValueLabel.text = price
        self.chartValueLabel.text = price
        
        self.titleLabel.text = viewModel.name
        
        self.returnLabel.text = "\(viewModel.overallGainPercent)%"
        self.costLabel.text = viewModel.initialCost
        
        self.changeValueButton.setTitle(viewModel.change24H, for: .normal)
        let change24 = viewModel.change24H.replacingOccurrences(of: "%", with: "")
        let change = Double(change24) ?? 0.0
        if change > 0 {
            self.changeValueButton.backgroundColor = UIView.theGreen
        } else {
            self.changeValueButton.backgroundColor = UIView.theRed
        }
        
        
        self.totalGainsLabel.text = "\(viewModel.overallGainValue)"
//        (\(viewModel.overallGainPercent))
        self.assetTableView.reloadData()
        pieChartUpdate()
        
        self.tableHeight.constant = assetTableView.contentSize.height + 20
        
        
        self.refresher.endRefreshing()
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
        
        
    }
    
    
    func displayCharts(viewModel: ShowPortfolio.FetchAssetCharts.ViewModel) {

        
        for asset in self.assetsOnDisplay {
            asset.symbol
        }
//        self.assetsOnDisplay
        let keys: [String] = Array(self.chartData.keys)
        self.chartData = viewModel.data

        
    }
    
    
    func displayPortfolioChart(viewModel: ShowPortfolio.FetchPortFolioChart.ViewModel) {
        lineChartUpdate(data: viewModel.data)
    }
    
    
    
    func lineChartUpdate(data: [(Int, Double, Double, Double, Double, Double)]) {
        if data.count == 0 {
            return
        }
        var lineChartEntries: [ChartDataEntry] = data.map({ChartDataEntry(x: Double($0.0), y: $0.1)})
        
        let start = lineChartEntries.first!.y
        let end = lineChartEntries.last!.y
        
//        for i in 0...96 {
//            
//            let diceRoll = Int(arc4random_uniform(20) + 1)
//            let value =  ChartDataEntry(x: Double(i), y: sin(Double(i)/180 * Double.pi))
//            lineChartEntries.append(value)
//
//        }
        let line1 = LineChartDataSet(values: lineChartEntries, label: nil)
        line1.colors = [ChartColorTemplates.joyful()[0]]
        if end - start > 0 {
            line1.colors = [UIView.theGreen]
        } else {
            line1.colors = [UIView.theRed]
        }
        line1.drawCirclesEnabled = false
        line1.drawValuesEnabled = false
        let data = LineChartData()
        data.addDataSet(line1)
        
        
        
        //        self.lineChart.drawGridBackgroundEnabled = false
        self.lineChart.xAxis.drawGridLinesEnabled = false
        self.lineChart.rightAxis.drawGridLinesEnabled = false
        self.lineChart.leftAxis.drawGridLinesEnabled = false
        self.lineChart.legend.enabled = false
        self.lineChart.rightAxis.enabled = false
        self.lineChart.leftAxis.enabled = false
        self.lineChart.xAxis.enabled = false
        self.lineChart.chartDescription = nil
        self.lineChart.extraTopOffset = 50.0
        
//        self.lineChart.extraBottomOffset = 10.0
        self.lineChart.data?.highlightEnabled = false
        self.lineChart.data = data
    }
    func pieChartUpdate() {
        let allColors = UIView.allColors
        self.colorsForAssets = []
        var entries: [PieChartDataEntry] = []
        if self.totalValueLabel.text == "$0.00" {
            let entry = PieChartDataEntry(value: 100)
            entries.append(entry)
//            self.colorsForAssets.append(UIColor.lightGray)
        } else {
            var count = 0
            
            for (index,asset) in self.assets.enumerated() {
//                if asset.total > 0 {
                
                let entry = PieChartDataEntry(value: asset.total > 0 ? asset.total : 0)
                entries.append(entry)
                self.colorsForAssets.append(allColors[index])
//                    count += 1
//                }
                
                
            }
        }
        
        
//        let entry1 = PieChartDataEntry(value: 20, label: nil)
//        let entry2 = PieChartDataEntry(value: 30, label: nil)
//        let entry3 = PieChartDataEntry(value: 40, label: nil)
        
        
        let dataSet = PieChartDataSet(values: entries, label: nil)
        
        let data = PieChartData(dataSet: dataSet)
         
        
        
        
//        pieChartView.chartDescription?.text = "Share of Widgets by Type"
        dataSet.drawValuesEnabled = false
        if self.totalValueLabel.text == "$0.00" {
            dataSet.colors = [UIColor.lightGray]
            //            self.colorsForAssets.append(UIColor.lightGray)
        } else {
            dataSet.colors = allColors
        }
        
        dataSet.valueColors = [UIColor.black]
        pieChartView.data = data
        
        //All other additions to this function will go here
        var angle: CGFloat = 0.0
        for (index, ang) in pieChartView.drawAngles.enumerated() {
            if self.assets.count > 0 {
                self.anglesForAssets[self.assets[index].symbol.lowercased()] = angle
                angle += ang
            }
            
        }
        
        pieChartView.backgroundColor = UIColor.clear
        pieChartView.holeColor = UIColor.clear
        pieChartView.entryLabelColor = UIColor.clear
//        pieChartView.centerText = "$76721"
        pieChartView.holeRadiusPercent = 0.93
        dataSet.selectionShift = 0.0
        dataSet.sliceSpace = 2.0
        pieChartView.chartDescription = nil
        pieChartView.legend.enabled = false
        pieChartView.rotationEnabled = false
//        pieChartView.isRotationEnabled = false
        
//        pieChartView.drawSliceTextEnabled = false
//        pieChartView.drawSlicesUnderHoleEnabled = true
//        pieChartView
        
        
        //This must stay at end of function
        pieChartView.notifyDataSetChanged()
    }
    
    
    
    @IBAction func changeAssetsDisplayed(sender: UIButton) {
        self.selectedAssets = sender.tag
        let prevHeight = self.tableHeight.constant
        switch sender.tag {
        case 1:
            self.assetsOnDisplay = []
            for asset in self.assets {
                if asset.total > 0.000001 && !asset.fiat {
                    self.assetsOnDisplay.append(asset)
                }
            }
            
        case 2:
            self.assetsOnDisplay = []
            for asset in self.assets {
                if asset.fiat {
                    self.assetsOnDisplay.append(asset)
                }
            }
        case 3:
            self.assetsOnDisplay = []
            for asset in self.assets {
                if asset.total < 0 {
                    self.assetsOnDisplay.append(asset)
                }
            }
        case 4:
            self.assetsOnDisplay = []
            for asset in self.assets {
                if asset.total == 0 && !asset.fiat {
                    self.assetsOnDisplay.append(asset)
                }
            }
        default:
            return
        }
        self.assetSwitches.map({ (button) in
            if button.tag == sender.tag {
                button.setTitleColor(UIColor.white, for: .normal)
                button.backgroundColor = UIView.theBlue
            } else {
                button.setTitleColor(UIColor.lightGray, for: .normal)
                button.backgroundColor = UIColor.clear
            }
            
            
        })
        self.selectorViews.map({ (view) in
            if view.tag == sender.tag {
                view.isHidden = true
            } else {
                view.isHidden = true
            }
            
        })
        
        sender.setTitleColor(UIColor.white, for: .normal)
        self.assetsOnDisplay.sort(by: { $0.0.total > $0.1.total })
        self.assetTableView.reloadData()
        updateTableHeight()
        
        
        
        
        
        
    }
    func updateTableHeight() {
        if self.assetTableView.contentSize.height > self.tableHeight.constant {
            self.tableHeight.constant = assetTableView.contentSize.height
        }
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
    }
    var tapToCloseGesture: UITapGestureRecognizer?
//    @IBAction func menu() {
//
//        self.performSegue(withIdentifier: "ShowAccount", sender: self)
//        return
////        self.tabBarController?.selectedIndex = 1
//        if self.navigationController?.navigationBar.layer.zPosition == -1 {
////            self.menuView.isHidden = true
//            self.navigationController?.navigationBar.layer.zPosition = 0
//            self.view.removeGestureRecognizer(self.tapToCloseGesture!)
//            collapseMenu()
//        } else {
//
////            self.menuView.isHidden = false
//
//            expandMenu()
//
//            self.navigationController?.navigationBar.layer.zPosition = -1
//            let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.closeMenu(_:)))
//            self.tapToCloseGesture = tapGesture
//            self.view.addGestureRecognizer(tapGesture)
//        }
//
//
//
//    }
    
    func closeMenu(_ sender: UITapGestureRecognizer) {
        self.view.removeGestureRecognizer(sender)
        if self.navigationController?.navigationBar.layer.zPosition == -1 {
//            self.menu()
        }
        
        
    }
//    @IBAction func switchToView(sender: UIButton) {
//        self.tabBarController?.selectedIndex = sender.tag - 1
//        self.menu()
//    }
    
    @IBAction func switchToSearch(sender: Any?) {
//        let view1 = self.view
//        let view2 = (self.tabBarController?.viewControllers![1] as! UINavigationController).viewControllers.first!.view
        self.tabBarController?.heroTabBarAnimationType = .slide(direction: .left)
        self.tabBarController?.selectedIndex = 1

//        UIView.transition(from: view1!, to: view2!, duration: 0.1, options: .curveLinear, completion: { (b) in
//            
//        })
        
    }
    @IBAction func switchToPortfolio(sender: Any?) {
//        let view1 = self.view
//        let view2 = (self.tabBarController?.viewControllers![2] as! UINavigationController).viewControllers.first!.view
        self.tabBarController?.heroTabBarAnimationType = .slide(direction: .right)
        self.tabBarController?.selectedIndex = 2
//        UIView.transition(from: view1!, to: view2!, duration: 1.0, options: .curveLinear, completion: { (b) in
//
//            })

    }
    @IBAction func close() {
//        self.navigationController?.popViewController(animated: true)
        self.view.heroModifiers = [.fade]
        self.navigationController?.popViewController(animated: true)
//        self.navigationController?.popViewController(animated: true)
    }
    func stopLoading() {
        print("charts loaded")
        self.isLoading = false
        self.refresher.endRefreshing()
//        self.assetTableView.isScrollEnabled = true
//        self.assetTableView.refreshControl?.endRefreshing()
        self.assetTableView.reloadData()
        self.updateTableHeight()
        
        
//        for asset in self.assets {
//            if asset.total > 0 && !asset.fiat {
//                let charts = self.chartData[asset.symbol]?["usd"] ?? []
//                
//            }
//        }
        lineChartUpdate(data: calcPortfolioChart())
        
    }
    func calcPortfolioChart() -> [(Int, Double, Double, Double, Double, Double)] {
        let temp: [(Int, Double, Double, Double, Double, Double)] = Array(repeating: (0,0,0,0,0,0), count: self.chartData.first?.value.first?.value.count ?? 0)
        var totalData: [(Int, Double, Double, Double, Double, Double)] = temp
//            defaultChartData.day!.count)
        //        for asset in self.portfolio.assets {
        //
        //        }
        
        let coins = self.assets.filter { (asset) -> Bool in
            return asset.total > 0 && !asset.fiat
            
        }
        let amounts = coins.map({ $0.amount })
        let charts = coins.map { (asset) -> [(Int, Double, Double, Double, Double, Double)] in
            self.chartData[asset.symbol]?["usd"] ?? temp
        }
        let zipped = zip(amounts,charts)
        let data = zipped.reduce((0.0,totalData), { (arg1:  (Double, [(Int, Double, Double, Double, Double, Double)]), arg2:  (Double, [(Int, Double, Double, Double, Double, Double)]) ) in
//            print(arg1.1.count, arg2.1.count)
            return (arg2.0, zip(arg1.1, arg2.1).map({
                
                let x = $0.1.0
                let price = $0.1.4
                let amount = arg2.0
                let y = $0.0.1 + price * amount
                let data: (Int, Double, Double, Double, Double, Double) = (x,y,0.0,0.0,0.0,0.0)
                return data
            }))
            //            zip($0.0, $1)
            
        })
        return data.1
    }
    
    
    
    
}

extension ShowPortfolioViewController: UITableViewDataSource {
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if self.isLoading {
            return 1
        }
        if self.selectedAssets == 4 {
            return self.watchlist.count > 0 ? watchlist.count : 1
        } else {
            return self.assetsOnDisplay.count > 0 ? assetsOnDisplay.count : 1
        }
        
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        if self.isLoading {
            let cell = tableView.dequeueReusableCell(withIdentifier: "LoadingCell") as! LoadingTableCell
            cell.refresher.startAnimating()
            return cell
        }
        

        let row = indexPath.row
        
        var cell: UITableViewCell = UITableViewCell()
        cell.heroID = ""
        if self.selectedAssets == 4 {
            if self.watchlist.count == 0 {
                let cell = tableView.dequeueReusableCell(withIdentifier: "EmptyTableViewCell")
                return cell!
            } else {
            
                let coin = self.watchlist[row]
                let c = tableView.dequeueReusableCell(withIdentifier: "WatchlistCell") as! WatchlistTableViewCell
                if self.chartData[coin.symbol.lowercased()]?[coin.quoteSymbol.lowercased()] == nil && self.canUpdateCharts{
                    self.canUpdateCharts = false
                    self.interactor?.fetchAssetCharts(request: ShowPortfolio.FetchAssetCharts.Request())
                }
                c.setCell(coin: coin, data: self.chartData[coin.symbol.lowercased()]?[coin.quoteSymbol.lowercased()] ?? [])
                cell = c
                return cell
            }
            
        } else {
            if self.assetsOnDisplay.count == 0 {
                let cell = tableView.dequeueReusableCell(withIdentifier: "EmptyTableViewCell")
                return cell!
            }
            let asset = self.assetsOnDisplay[row]
            if self.chartData[asset.symbol.lowercased()]?["usd"] == nil && self.canUpdateCharts{
                self.canUpdateCharts = false
                self.interactor?.fetchAssetCharts(request: ShowPortfolio.FetchAssetCharts.Request())
            }
            for (index, each) in self.assets.enumerated() {
                if each.coinName == asset.coinName {
                    var color: UIColor
                    if index < colorsForAssets.count {
                     color = self.colorsForAssets[index]
                    } else {
                        color = UIColor.lightGray
                    }
                    
                    if !each.fiat {
                        let c = tableView.dequeueReusableCell(withIdentifier: "AssetCell") as! AssetTableViewCell
                        
                        var rotation: CGFloat = self.anglesForAssets[asset.symbol] ?? 0.0
                        
                        
                        
                        c.setCell(asset: self.assetsOnDisplay[indexPath.row],  color: color, rotation: rotation, data: self.chartData[asset.symbol]?["usd"] ?? [])
                        cell = c
                    } else {
                        
                        let c = tableView.dequeueReusableCell(withIdentifier: "FiatAssetCell") as! FiatAssetTableViewCell
                        c.setCell(asset: self.assetsOnDisplay[indexPath.row], color: color)
                        cell = c
                    }
                    
                    
                    //                if self.chartData.count <= indexPath.row {
                    //                    cell.setCell(asset: self.assetsOnDisplay[indexPath.row], color: color, data: [])
                    //                } else {
                    //
                    //                }
                    
                }
            }
        }
        
        
        
        return cell
    }
}
extension ShowPortfolioViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if self.isLoading {
            return
        }
        let row = indexPath.row
//        self.navigationController!.heroNavigationAnimationType = HeroDefaultAnimationType.auto
        if self.selectedAssets == 4 {
            if self.watchlist.count == 0 {
                self.tabBarController?.heroTabBarAnimationType = .slide(direction: .left)
                self.tabBarController?.selectedIndex = 1
                tableView.deselectRow(at: indexPath, animated: true)
                return
            }
//            self.performSegue(withIdentifier: "ShowCoin", sender: tableView)
//            tableView.dequeueReusableCell(withIdentifier: "WatchlistCell", for: indexPath).heroID = "bigView"
            self.router?.routeToShowCoin()
            
//            self.performSegue(withIdentifier: "ShowCoin", sender: tableView)
            tableView.deselectRow(at: indexPath, animated: true)
            return
        }
        if self.assetsOnDisplay.count == 0 {
            self.tabBarController?.heroTabBarAnimationType = .slide(direction: .left)
            self.tabBarController?.selectedIndex = 1
            tableView.deselectRow(at: indexPath, animated: true)
            return
        }
        if self.assetsOnDisplay[row].fiat  {
            tableView.deselectRow(at: indexPath, animated: true)
            return
        }
        
//        print(PortfolioWorker.sharedInstance.portfolio.assets[row].coin.name)
        self.router?.routeToShowCoin()
//            self.performSegue(withIdentifier: "ShowCoin", sender: tableView)
        tableView.deselectRow(at: indexPath, animated: true)
    }
}
extension ShowPortfolioViewController: ChartViewDelegate {
    func chartValueSelected(_ chartView: ChartViewBase, entry: ChartDataEntry, highlight: Highlight) {
        let price = entry.y
        self.chartValueLabel.text = "$\(price)"
    }
}
extension ShowPortfolioViewController: UIGestureRecognizerDelegate {
    func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
        return false
    }
}
