//
//  ShowCoinViewController.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Charts
import SafariServices
//import SwiftCharts

protocol ShowCoinDisplayLogic: class
{
    func displayCoin(viewModel: ShowCoin.ShowCoin.ViewModel)
//    func displayExchanges(viewModel: ShowCoin.FetchExchangesAndPair.ViewModel)
    func displayHoldings(viewModel: ShowCoin.FetchHoldings.ViewModel)
    
    func displayCharts(viewModel: ShowCoin.FetchChart.ViewModel)
    
    func displayAddToWatchlist()
    func displayRemoveFromWatchlist()
    
}

class ShowCoinViewController: UIViewController, ShowCoinDisplayLogic
{
    var interactor: ShowCoinBusinessLogic?
    var router: (NSObjectProtocol & ShowCoinRoutingLogic & ShowCoinDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = ShowCoinInteractor()
        let presenter = ShowCoinPresenter()
        let router = ShowCoinRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        CodeTimer.set()
        transactionButtonsView.isHidden = false
        
        navigationController?.heroNavigationAnimationType = .auto
//        navigationController?.interactivePopGestureRecognizer?.isEnabled = true
        navigationController?.navigationBar.setBackgroundImage(UIImage(), for: UIBarMetrics.default)
        navigationController?.navigationBar.shadowImage = UIImage()
//        navigationController?.heroNavigationAnimationType = .pull(direction: .left)
        
        
        setupButtons()
        setupQuoteCollection()
        setupBottomView()
        setupInfoView()
        setupCharts()
        setupRefresher()
        
        self.collectionHeight.constant = 0
        self.view.layoutIfNeeded()
        fetchHoldings()
//        fetchCoin()
        

        
        
        
        
        self.navigationController?.interactivePopGestureRecognizer?.delegate = nil
        
//        self.openArrow.transform = openArrow.transform.rotated(by: CGFloat(Double.pi))
        self.bottomArrows.map({
            $0.transform = $0.transform.rotated(by: CGFloat(Double.pi))
        })
        CodeTimer.finish()
    }
    override func viewWillAppear(_ animated: Bool) {
        
    }
    override func viewDidAppear(_ animated: Bool) {
        fetchCoin()
        navigationController?.heroNavigationAnimationType = .auto
        self.navigationController?.interactivePopGestureRecognizer?.delegate = nil
        self.refresher.didMoveToSuperview()
//        navigationController?.interactivePopGestureRecognizer?.isEnabled = true
//        self.navigationController?.heroNavigationAnimationType = .auto
    }
    override func viewWillDisappear(_ animated: Bool) {
//        navigationController?.heroNavigationAnimationType = .pull(direction: .right)
    }
    
    
    
    // MARK: Do something
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var currencyButton: UIButton!
    @IBOutlet weak var exchangeButton: UIButton!
    @IBOutlet weak var quoteBarButton: UIBarButtonItem!
    @IBOutlet weak var timeLabel: UILabel!
//    @IBOutlet weak var otherExchangesButton: UIButton!
//    @IBOutlet weak var overallCoinButton: UIButton!

    
    @IBOutlet weak var priceLabel: UILabel!
//    @IBOutlet weak var quoteNameLabel: UILabel!
    @IBOutlet weak var percentLabel: UILabel!
    @IBOutlet weak var openLabel: UILabel!
    @IBOutlet weak var volumeLabel: UILabel!
    @IBOutlet weak var high24Label: UILabel!
    @IBOutlet weak var low24Label: UILabel!
    @IBOutlet weak var mktCapLabel: UILabel!
    
    @IBOutlet weak var holdingValueLabel: UILabel!
    @IBOutlet weak var holdingPercentLabel: UILabel!
//    @IBOutlet weak var holdingInitialLabel: UILabel!
//    @IBOutlet weak var profitLossButton: UIButton!
//    @IBOutlet weak var holdingChangeLabel: UILabel!
//    @IBOutlet weak var holdingAmountLabel: UILabel!
    @IBOutlet weak var holdingsView: UIView!
    @IBOutlet weak var holdingButton: UIButton!
//    @IBOutlet weak var holdingsPieChart: PieChartView!
    
    @IBOutlet weak var quotesCollectionView: UICollectionView!
    
    @IBOutlet weak var collectionHeight: NSLayoutConstraint!
    @IBOutlet weak var holdingsHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var chartHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var volumeChartOffset: NSLayoutConstraint!
    @IBOutlet weak var descriptionHeightConstraint: NSLayoutConstraint!
    
    @IBOutlet weak var chartHighLabel: UILabel!
    @IBOutlet weak var chartLowLabel: UILabel!
    @IBOutlet weak var chartOpenLabel: UILabel!
    @IBOutlet weak var chartCloseLabel: UILabel!
    @IBOutlet weak var chartVolumeLabel: UILabel!
    
    @IBOutlet var durationButtons: [UIButton]!
//    @IBOutlet var filterSelectionButtons: [UIButton]!
//    @IBOutlet var filterSelectionIndicators: [UIView]!
    
    @IBOutlet var pairSearchBar: UISearchBar!
    
    
    
    
    
    @IBOutlet weak var transactionButtonsView: UIView!
    @IBOutlet weak var infoContainerView: UIView!
    @IBOutlet weak var scrollView: UIScrollView!
    
    @IBOutlet weak var buyButton: UIButton!
    @IBOutlet weak var sellButton: UIButton!
    @IBOutlet weak var watchButton: UIButton!
    @IBOutlet weak var websiteButton: UIButton!
    @IBOutlet weak var readMoreButton: UIButton!
//    @IBOutlet weak var addButton: UIButton!
    
    
    @IBOutlet weak var candleIndicator: UIView!
    @IBOutlet var redArrows: [UIImageView]!
    @IBOutlet var greenArrows: [UIImageView]!
    @IBOutlet var bottomArrows: [UIImageView]!
//    @IBOutlet weak var candleStartIndicator: UIView!
//    @IBOutlet weak var candleEndIndicator: UIView!
    @IBOutlet weak var candleStartLength: NSLayoutConstraint!
    @IBOutlet weak var candleIndicatorWidth: NSLayoutConstraint!
//    @IBOutlet weak var openLeftConstraint: NSLayoutConstraint!
//    @IBOutlet weak var openRightConstraint: NSLayoutConstraint!
    
    @IBOutlet weak var descriptionLabel: UILabel!
    
//    @IBOutlet weak var overallIndicatorView: UIView!
//    @IBOutlet weak var exchangeIndicatorView: UIView!
    
    
    @IBOutlet weak var lineChart: CombinedChartView!
    
    var displayedExchange: String = ""
    var displayedQuote: String = ""
    var transactionType: Transaction.OrderType = .Buy
    var quotes: [String] = []
    var exchanges: [String] = []
    
    var refresher: UIRefreshControl!
    
    var displayed: ShowCoin.ShowCoin.ViewModel?
    var displayingHoldingValue: Bool = true
    
    var displayedSelections: [String] = []
    
    func setupButtons() {
//        addButton.layer.borderColor = UIView.theBlue.cgColor
//        currencyButton.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        currencyButton.titleLabel?.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        currencyButton.imageView?.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        
//        exchangeButton.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        exchangeButton.titleLabel?.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        exchangeButton.imageView?.transform = CGAffineTransform(scaleX: -1.0, y: 1.0)
//        currencyButton.layer.borderColor = UIColor.white.cgColor
//        currencyButton.layer.borderWidth = 1.0
//        currencyButton.layer.shadowColor = UIColor.black.cgColor
//        currencyButton.layer.shadowRadius = 3
//        currencyButton.layer.shadowOpacity = 0.7
    }
    func setupRefresher() {
        self.refresher = UIRefreshControl()
        refresher.addTarget(self, action: #selector(fetchCoin), for: .valueChanged)
        self.scrollView.refreshControl = refresher
        self.scrollView.isScrollEnabled = true
        self.scrollView.alwaysBounceVertical = true
        
    }
    func setupBottomView() {
        let tap = UITapGestureRecognizer(target: self, action: #selector(dismissSelectionView))
        self.scrollView.addGestureRecognizer(tap)
//        self.view.addGestureRecognizer(tap)
        
        let swipeDown = UISwipeGestureRecognizer(target: self, action: #selector(dismissSelectionView))
        let swipeUp = UISwipeGestureRecognizer(target: self, action: #selector(bringUpSelectionView))
        
        
        
        swipeDown.direction = UISwipeGestureRecognizerDirection.down
        swipeUp.direction = .up
        
        self.transactionButtonsView.addGestureRecognizer(swipeDown)
//        self.transactionButtonsView.addGestureRecognizer(swipeUp)
//        self.transactionButtonsView.addGestureRecognizer(tap)
    }
    func setupQuoteCollection() {
//        self.quotesCollectionView.register("QuoteCollectionViewCell", forCellWithReuseIdentifier: "QuoteCell")
        self.quotesCollectionView.register(UINib(nibName: "QuoteCollectionViewCell", bundle: nil), forCellWithReuseIdentifier: "QuoteCell")
        self.transactionButtonsView.layer.borderWidth = 0.6
        self.transactionButtonsView.layer.borderColor = UIColor.lightGray.cgColor
        
    }
    func setupInfoView() {
        
        self.infoContainerView.layer.shadowColor = UIColor.darkGray.cgColor
        
        self.infoContainerView.layer.shadowOffset = CGSize(width: 0.5, height: 0.5)
    }
    
    func fetchHoldings() {
        let req = ShowCoin.FetchHoldings.Request()
        self.interactor?.fetchHoldings(request: req)
    }
    
    
    
    func fetchCoin()
    {
        if self.displayedExchange != "" && self.displayedQuote != "" {
//            print(self.displayedQuote)
            let request = ShowCoin.ShowCoin.Request(exchange: self.displayedExchange, quote: self.displayedQuote)
            interactor?.fetchCoin(request: request)
        } else {
            let request = ShowCoin.ShowCoin.Request(exchange: "CCCAGG", quote: "usd")
            interactor?.fetchCoin(request: request)
        }
        
    }
    func fetchExchanges() {
        let req = ShowCoin.FetchExchangesAndPair.Request()
        interactor?.fetchExchangesAndPair(request: req, completion: fetchCoin)
    }
    @IBAction func readMore() {
        if self.descriptionHeightConstraint.constant == 2000 {
            UIView.animate(withDuration: 0.3) {
                self.descriptionHeightConstraint.constant = 200
                self.readMoreButton.setTitle("Show more", for: .normal)
                self.view.setNeedsLayout()
                self.view.layoutIfNeeded()
            }
        } else {
            UIView.animate(withDuration: 0.3) {
                self.descriptionHeightConstraint.constant = 2000
                self.readMoreButton.setTitle("Show less", for: .normal)
                self.view.setNeedsLayout()
                self.view.layoutIfNeeded()
            }
        }
        
    }
    @IBAction func back() {
//        self.navigationController?.dismiss(animated: true, completion: nil)
//        self.dismiss(animated: true, completion: nil)
        navigationController?.heroNavigationAnimationType = .auto
        self.navigationController?.popViewController(animated: true)
    }
    
    @IBAction func doTransaction(sender: UIButton?) {
        if sender != nil && sender?.tag == 1 {
            self.transactionType = .Buy
        } else if sender != nil {
            self.transactionType = .Sell
        }
        self.performSegue(withIdentifier: "AddTransaction", sender: self)
    }
    @IBAction func showWebsite() {
        if let url = URL(string: self.displayed?.url ?? "") {
            let svc = SFSafariViewController(url: url)
            self.present(svc, animated: true, completion: nil)
        }
//        print(self.displayed!.url)
//        print(URL(string: self.displayed?.url ?? "What1") ?? "What2")
        
    }
    @IBAction func addToWatchlist() {
        if self.watchButton.title(for: .normal) == "Watch" {
            self.interactor?.addToWatchlist()
        } else {
            self.interactor?.removeFromWatchlist()
        }
        
    }
    
    @IBAction func switchCharts(sender: UIButton?) {
        let durations: [ShowCoin.Duration] = [.Day, .Week, .Month, .Month3, .Year]
        
        if let button = sender {
            var req = ShowCoin.FetchChart.Request(duration: durations[sender!.tag - 1])
            self.durationButtons.map({ $0.setTitleColor(UIColor.darkGray, for: .normal) })
            sender!.setTitleColor(UIView.theBlue, for: .normal)
            self.interactor?.fetchCharts(request: req, force: false)
        }
    }
    
    @IBAction func displayQuoteSelection() {
        if self.isSelectionViewUp && self.currencyButton.backgroundColor == UIView.theBlue {
            self.dismissSelectionView()
            return
        }
        self.pairSearchBar.placeholder = "Search All Quotes..."
//        self.filterSelectionButtons.map({
//            if $0.tag == 1 {
//                $0.setTitle("All Quotes", for: .normal)
//            } else {
//                $0.setTitle("In \(self.displayedExchange.capitalized)", for: .normal)
//            }
//
//        })
        
        self.displayedSelections = self.quotes
        self.quotesCollectionView.reloadData()
        self.quotesCollectionView.setContentOffset(CGPoint.zero, animated: false)
        if self.collectionHeight.constant == 303 {
            UIView.animate(withDuration: 0.2, animations: {
                
            })
        } else {
            bringUpSelectionView()
        }
        self.exchangeButton.backgroundColor = UIColor.groupTableViewBackground
        self.currencyButton.backgroundColor = UIView.theBlue
        self.currencyButton.setTitleColor(UIColor.white, for: .normal)
        self.exchangeButton.setTitleColor(UIColor.black, for: .normal)
        
    }
    
    var isSelectionViewUp: Bool {
        return self.collectionHeight.constant == 450
    }
    func bringUpSelectionView() {
//        self.exchangeButton.backgroundColor = UIColor.groupTableViewBackground
//        self.currencyButton.backgroundColor = UIColor.white
        if self.collectionHeight.constant != 450 {
            self.quotesCollectionView.reloadData()
            UIView.animate(withDuration: 0.2, animations: {
                self.scrollView.alpha = 0.4
                self.collectionHeight.constant = 450
                
                self.view.layoutIfNeeded()
            })
        }
        
    }
    func dismissSelectionView() {
        self.view.endEditing(true)
        self.currencyButton.backgroundColor = UIView.theBlue
        self.exchangeButton.backgroundColor = UIColor.groupTableViewBackground
        self.quotesCollectionView.setContentOffset(CGPoint.zero, animated: false)
        UIView.animate(withDuration: 0.2, animations: {
            self.scrollView.alpha = 1.0
            self.collectionHeight.constant = 0
            self.view.layoutIfNeeded()
        })
    }
    @IBAction func displayExchangeSelection() {
        if self.isSelectionViewUp && self.exchangeButton.backgroundColor == UIView.theBlue {
            self.dismissSelectionView()
            return
        }
        
        self.pairSearchBar.placeholder = "Search exchanges that trade \(self.displayedQuote.uppercased())"
//        self.filterSelectionButtons.map({
//            if $0.tag == 1 {
//                $0.setTitle("All Exchanges", for: .normal)
//            } else {
//                $0.setTitle("Has \(self.displayedQuote.uppercased())", for: .normal)
//            }
//
//        })
        
        self.displayedSelections = self.exchanges
        self.quotesCollectionView.reloadData()
        self.quotesCollectionView.setContentOffset(CGPoint.zero, animated: false)
        if self.collectionHeight.constant == 303 {
            UIView.animate(withDuration: 0.2, animations: {
                
            })
        } else {
            bringUpSelectionView()
        }
        self.currencyButton.backgroundColor = UIColor.groupTableViewBackground
        self.exchangeButton.backgroundColor = UIView.theBlue
        self.currencyButton.setTitleColor(UIColor.black, for: .normal)
        self.exchangeButton.setTitleColor(UIColor.white, for: .normal)
        
        
    }
    
    
    func changeQuoteAndExchange(info: String) {
        if self.quotes.contains(info) {
            self.currencyButton.setTitle(info, for: .normal)
            self.displayedQuote = info
//            self.displayedExchange = self.exchangeButton.title(for: .normal)!
            self.displayExchangeSelection()
            
            
        } else if self.exchanges.contains(info) {
            if self.displayedExchange == info {
                self.dismissSelectionView()
                return
            }
            self.exchangeButton.setTitle(info, for: .normal)
            self.displayedExchange = info
//            self.displayedQuote = self.currencyButton.title(for: .normal)!.lowercased()
            self.dismissSelectionView()
            
        }
        
        self.fetchCoin()
    }
    
    @IBAction func switchFilters(sender: UIButton) {
//        if sender.tag == 1 {
//            self.filterSelectionIndicators.map({
//                if $0.tag == 1 {
//                    $0.isHidden = false
//                    
//                } else {
//                    $0.isHidden = true
//                }
//                
//            })
//            self.filterSelectionButtons.map({
//                if $0.tag == 1 {
//                    $0.setTitleColor(UIView.theBlue, for: .normal)
//                    
//                } else {
//                    $0.setTitleColor(UIColor.lightGray, for: .normal)
//                }
//            })
//            
//        } else if sender.tag == 2 {
//            self.filterSelectionIndicators.map({
//                if $0.tag == 1 {
//                    $0.isHidden = true
//                } else {
//                    $0.isHidden = false
//                }
//                
//            })
//            self.filterSelectionButtons.map({
//                if $0.tag == 1 {
//                    $0.setTitleColor(UIColor.lightGray, for: .normal)
//                } else {
//                    $0.setTitleColor(UIView.theBlue, for: .normal)
//                }
//            })
//        }
    }
    
    
    @IBAction func fetchCoinFromExchange() {
//        self.overallCoinButton.setTitleColor(.lightGray, for: .normal)
//        self.firstExchangeButton.setTitleColor(.white, for: .normal)
//        self.overallIndicatorView.isHidden = true
//        self.exchangeIndicatorView.isHidden = false
        
        let req = ShowCoin.ShowCoin.Request(exchange: self.displayedExchange, quote: self.displayedQuote)
        interactor?.fetchCoin(request: req)
    }
    @IBAction func fetchOverallInfo() {
        self.fetchCoin()
//        self.overallCoinButton.setTitleColor(.white, for: .normal)
//        self.firstExchangeButton.setTitleColor(.lightGray, for: .normal)
//        self.overallIndicatorView.isHidden = false
//        self.exchangeIndicatorView.isHidden = true
    }
    @IBAction func changeExchange() {
//        print("here")
    }
    @IBAction func changeHoldingDisplay() {
        if displayingHoldingValue {
            self.holdingValueLabel.text = (self.holdingModel?.amount)!
            displayingHoldingValue = false
        } else {
            displayingHoldingValue = true
            self.holdingValueLabel.text = "$\((self.holdingModel?.marketValue)!)"
        }
    }
    
    func displayAddToWatchlist() {
        self.watchButton.setTitle("", for: .normal)
        self.watchButton.setImage(#imageLiteral(resourceName: "checkmark-white"), for: .normal)
    }
    func displayRemoveFromWatchlist() {
        self.watchButton.setTitle("Watch", for: .normal)
        self.watchButton.setImage(nil, for: .normal)
    }
    var holdingModel: ShowCoin.FetchHoldings.ViewModel?
    func displayHoldings(viewModel: ShowCoin.FetchHoldings.ViewModel) {
        self.holdingModel = viewModel
        if viewModel.watchlist {
            displayAddToWatchlist()
        } else {
            displayRemoveFromWatchlist()
        }
        if !viewModel.exists {
            
            self.holdingsView.isHidden = true
            self.holdingsHeightConstraint.constant = 0
            return
        }
//        self.setupPiechart()
        self.holdingsView.isHidden = false
        self.holdingValueLabel.text = "$\(viewModel.marketValue)"
        self.holdingPercentLabel.text = "\(String(format: "%.2f", viewModel.percentHoldings * 100))% of portfolio"
        self.displayHoldingsBar()
//        self.holdingsHeightConstraint.constant = 128
//        self.holdingValueLabel.text = viewModel.marketValue
//        self.holdingInitialLabel.text = "$100.23"
//        self.holdingChangeLabel.text = viewModel.change24H
//        self.holdingAmountLabel.text = viewModel.amount
        
//        self.profitLossButton.setTitle("$1232.10", for: .normal)
        
    }
    @IBOutlet weak var holdingWidthConstraint: NSLayoutConstraint!
    func displayHoldingsBar() {
        let totalWidth: Double = Double(self.view.bounds.width - 40)
        let percent: Double = (self.holdingModel?.percentHoldings)!
        let holdingWidth: Double = percent * totalWidth
        
        self.holdingWidthConstraint.constant = CGFloat(holdingWidth)
        
        
    }
//    func setupPiechart() {
//        let allColors = UIView.allColors
//        let entry1 = PieChartDataEntry(value: 30.0)
//        let entry2 = PieChartDataEntry(value: 70.0)
//        var entries: [PieChartDataEntry] = [entry1, entry2]
//
//        let dataSet = PieChartDataSet(values: entries, label: nil)
//
//        let data = PieChartData(dataSet: dataSet)
//
//        dataSet.drawValuesEnabled = false
//        dataSet.colors = [allColors[1], UIColor.lightGray]
//        dataSet.valueColors = [UIColor.black]
//        holdingsPieChart.data = data
//        //All other additions to this function will go here
//        holdingsPieChart.backgroundColor = UIColor.clear
//        holdingsPieChart.holeColor = UIColor.clear
//        holdingsPieChart.entryLabelColor = UIColor.clear
//        //        pieChartView.centerText = "$76721"
//        holdingsPieChart.holeRadiusPercent = 0.93
//        dataSet.selectionShift = 0.0
//        holdingsPieChart.chartDescription = nil
//        holdingsPieChart.legend.enabled = false
//        holdingsPieChart.rotationEnabled = false
//        //        pieChartView.isRotationEnabled = false
//
//        //        pieChartView.drawSliceTextEnabled = false
//        //        pieChartView.drawSlicesUnderHoleEnabled = true
//        //        pieChartView
//
//
//        //This must stay at end of function
//        holdingsPieChart.notifyDataSetChanged()
//    }
    
    func displayCoin(viewModel: ShowCoin.ShowCoin.ViewModel)
    {
        
        self.displayed = viewModel
        
        if viewModel.details.characters.count > 400 {
            self.readMoreButton.isHidden = false
        } else {
            self.readMoreButton.isHidden = true
        }
        
        self.nameLabel.text = "\(viewModel.name.capitalized) (\(viewModel.symbol.uppercased()))"
        self.volumeLabel.text = "\(viewModel.volume)"
        self.priceLabel.text = viewModel.price
        self.percentLabel.text = viewModel.percent
        self.high24Label.text = viewModel.high24
        self.low24Label.text = viewModel.low24
        self.mktCapLabel.text = viewModel.cap
        self.openLabel.text = viewModel.open
        if !viewModel.didIncrease {
            self.percentLabel.textColor = UIView.theRed
        }
//        self.currencyButton.setTitle(viewModel.quote, for: .normal)
        
//        self.quoteNameLabel.text = self.displayedQuote.uppercased()
        
        
//        print(viewModel.quotes)
        if viewModel.url == "" {
            self.websiteButton.isHidden = true
        } else {
            self.websiteButton.isHidden = false
        }
        self.timeLabel.text = viewModel.date
        let font = self.descriptionLabel.font
        self.descriptionLabel.attributedText = String.stringFromHtml(string: viewModel.details, font: self.descriptionLabel.font)
        self.descriptionLabel.font = font
        self.exchangeButton.setTitle(viewModel.exchange, for: .normal)
        self.currencyButton.setTitle("\(viewModel.symbol.uppercased())/\(viewModel.quote)", for: .normal)
        self.quoteBarButton.title = viewModel.quote.uppercased()
        self.displayedExchange = viewModel.exchange
        
        
        self.quotes = viewModel.quotes
        self.exchanges = viewModel.exchanges
        transactionButtonsView.isHidden = false
        
        if self.isSelectionViewUp && self.currencyButton.backgroundColor == UIView.theBlue {
            self.displayedSelections = self.quotes
            
        } else if self.isSelectionViewUp && self.currencyButton.backgroundColor != UIView.theBlue  {
            self.displayedSelections = self.exchanges
        } else {
            self.displayedSelections = self.quotes
        }

        self.displayedQuote = viewModel.quote.lowercased()
//        if viewModel.exchangeName != "" {
//            transactionButtonsView.isHidden = false
//        }
//        print(viewModel.quotes)
        
        
        
        
        self.quotesCollectionView.reloadData()
        
        self.displayCandlestick(open: viewModel.data.open, high: viewModel.data.high, low: viewModel.data.low, close: viewModel.data.close)
        
        
    }
    
//    @IBOutlet weak var openArrow: UIImageView!
//    @IBOutlet weak var closeArrow: UIImageView!
    func displayCandlestick(open: Double, high: Double, low: Double, close: Double) {
        self.low24Label.text = String(format: "%.3f", low)
        self.high24Label.text = String(format: "%.3f", high)
        self.openLabel.text = String(format: "%.3f", open)
        let formattedChange = String(format: "%.2f", (close - open))
        let formattedPercent = String(format: "%.2f", (close - open)/open * 100)
        self.percentLabel.text = "\(formattedChange) (\(formattedPercent)%)"
//        self..text = "\(low)"
        let totalWidth: CGFloat = (self.view.frame.width) - 40.0
        var width: CGFloat = CGFloat((abs(open-close)/(high-low))) * totalWidth
        let a: CGFloat = CGFloat(abs(open-close)/(high-low))
        
        if a.isNaN || a.isInfinite {
            width = 0.0
        } else {
            
            width = a * (totalWidth)
        }
        
        
//        self.candleStartLength = 
        self.candleIndicatorWidth.constant = width
        
        var start: CGFloat = 0.0
        if close - open > 0 {
            let a: CGFloat = CGFloat((open-low)/(high-low))
            if a.isNaN || a.isInfinite {
                start = 0.0
            } else {
                
                start = a * (totalWidth - width)
            }
//            start = CGFloat((open-low)/(high-low)) * (totalWidth - width)
            self.candleIndicator.backgroundColor = UIView.theGreen
            self.greenArrows.map({
                $0.isHidden = false
            })
            self.redArrows.map({
                $0.isHidden = true
            })
//            self.candleStartIndicator.backgroundColor = UIView.theGreen
//            self.candleEndIndicator.backgroundColor = UIView.theGreen
//            self.openLeftConstraint.isActive = true
//            self.openRightConstraint.isActive = false
        } else if close - open < 0  {
            let a: CGFloat = CGFloat((close-low)/(high-low))
            if a.isNaN || a.isInfinite {
                start = 0.0
                
            } else {
                start = a * (totalWidth - width)
            }
            
            self.candleIndicator.backgroundColor = UIView.theRed
            self.greenArrows.map({
                $0.isHidden = true
            })
            self.redArrows.map({
                $0.isHidden = false
            })
//            self.candleStartIndicator.backgroundColor = UIView.theRed
//            self.candleEndIndicator.backgroundColor = UIView.theRed
//            self.openLeftConstraint.isActive = false
//            self.openRightConstraint.isActive = true
        } else {
            let a: CGFloat = CGFloat((close-low)/(high-low))
            if a.isNaN || a.isInfinite {
                start = 0.0
                
            } else {
                start = a * (totalWidth - width)
            }
            self.candleIndicator.backgroundColor = UIColor.lightGray
        }
        self.candleStartLength.constant = start
        
        UIView.animate(withDuration: 0.2, animations: {
            self.view.setNeedsLayout()
            self.view.layoutIfNeeded()
        })
        
        
        
        
    }
    
    
    @IBOutlet weak var barChart: BarChartView!
    func setupCharts() {
        self.lineChart.delegate = self
        //        var lineChartEntries: [ChartDataEntry] = []
        //
        //        for i in 0...24 {
        //            let diceRoll = Int(arc4random_uniform(20) + 1)
        //            let value =  ChartDataEntry(x: Double(i), y: Double(diceRoll))
        //            lineChartEntries.append(value)
        //
        //        }
        //
        //        let line1 = LineChartDataSet(values: lineChartEntries, label: nil)
        //        line1.colors = [ChartColorTemplates.joyful()[0]]
        //        line1.drawCirclesEnabled = false
        //        line1.drawValuesEnabled = false
        //        let data = LineChartData()
        //        data.addDataSet(line1)
        
        
        
        self.lineChart.drawGridBackgroundEnabled = false
        self.lineChart.xAxis.drawGridLinesEnabled = false
        self.lineChart.rightAxis.drawGridLinesEnabled = true
        self.lineChart.leftAxis.drawGridLinesEnabled = false
        self.lineChart.rightAxis.gridColor = UIColor(red: 230/255.0, green: 230/255.0, blue: 230/255.0, alpha: 1.0)
        self.lineChart.legend.enabled = false
        self.lineChart.rightAxis.drawAxisLineEnabled = false
        self.lineChart.rightAxis.enabled = true
        self.lineChart.rightAxis.labelTextColor = UIColor.lightGray
        self.lineChart.leftAxis.enabled = false
        
        self.lineChart.xAxis.enabled = false
        //        self.lineChart.xAxis.labelPosition = .bottom
        self.lineChart.chartDescription = nil
//        self.lineChart.extraBottomOffset = 16.0
        //        self.lineChart.extraBottomOffset = 50.0
        self.lineChart.data?.highlightEnabled = false
        
        self.lineChart.setScaleEnabled(false)
        
        self.barChart.setScaleEnabled(false)
        self.barChart.drawValueAboveBarEnabled = false
        
        self.barChart.drawGridBackgroundEnabled = false
        self.barChart.xAxis.drawGridLinesEnabled = false
        self.barChart.rightAxis.drawGridLinesEnabled = false
        self.barChart.leftAxis.drawGridLinesEnabled = false
        self.barChart.leftAxis.enabled = false
        self.barChart.legend.enabled = false
        self.barChart.rightAxis.enabled = false
        self.barChart.rightAxis.drawAxisLineEnabled = false
        self.barChart.rightAxis.labelTextColor = UIColor.clear
        
        
        
        self.barChart.extraBottomOffset = 0.0
        self.barChart.chartDescription = nil
        
        //        self.barChart.leftAxis.enabled = false
        
        self.barChart.xAxis.enabled = false
        
        //        self.lineChart.data = data
        self.barChart.barData?.highlightEnabled = false
        
        self.lineChart.data?.highlightEnabled = false
        self.lineChart.candleData?.highlightEnabled = false
        self.lineChart.highlightPerDragEnabled = false
        self.lineChart.highlightPerTapEnabled = false
        self.lineChart.extraLeftOffset = 0.0
        let hold: UILongPressGestureRecognizer = UILongPressGestureRecognizer(target: self, action: #selector(enableGraph))
        hold.minimumPressDuration = 0.2
        self.lineChart.addGestureRecognizer(hold)
        
        self.barChart.backgroundColor = UIColor.clear
        self.lineChart.backgroundColor = UIColor.clear
        
        
    }
    func enableGraph(sender: UILongPressGestureRecognizer) {
        self.dismissSelectionView()
        
        if self.displayed == nil {
            return
        }
        if sender.state == .ended {
//            print("disabled")
            self.lineChart.highlightPerDragEnabled = false
            self.lineChart.highlightPerTapEnabled = false
            self.lineChart.highlightValue(nil)
            
            self.priceLabel.text = "\(self.displayed!.price)"
            self.high24Label.text = "\(self.displayed!.high24)"
            self.low24Label.text = "\(self.displayed!.low24)"
            self.openLabel.text = "\(self.displayed!.open)"
            self.volumeLabel.text = "\(self.displayed!.volume)"
            self.displayCandlestick(open: self.displayed!.data.open, high: self.displayed!.data.high, low: self.displayed!.data.low, close: self.displayed!.data.close)
//            self.scrollView.isScrollEnabled = true
        } else {
            let loc = sender.location(in: self.lineChart)
            let highlight = self.lineChart.getHighlightByTouchPoint(loc)
            self.lineChart.highlightValue(highlight)
//            let vol = self.barChart.getHighlightByTouchPoint(loc)
//            let bar = self.barChart.getEntryByTouchPoint(point: CGPoint(x: loc.x, y: 0.0)) as! BarChartDataEntry
//            let vol = bar.
            if let ohlc = self.lineChart.getEntryByTouchPoint(point: loc) as? CandleChartDataEntry {
                //            print(ohlc)
                self.priceLabel.text = "\(ohlc.close)"
                self.high24Label.text = "\(ohlc.high)"
                self.low24Label.text = "\(ohlc.low)"
                self.openLabel.text = "\(ohlc.open)"
                //            self.volumeLabel.text = "\(vol)"
                self.displayCandlestick(open: ohlc.open, high: ohlc.high, low: ohlc.low, close: ohlc.close)
                //            print("enabled")
                self.lineChart.highlightPerDragEnabled = true
                self.lineChart.highlightPerTapEnabled = true
                //            self.scrollView.isScrollEnabled = false
//                print(ohlc.x)
                
                let volEntry: ChartDataEntry = self.barChart.data!.getDataSetByIndex(0).entryForIndex(Int(ohlc.x))!
                let vol: String = Pair().toString(d: volEntry.y)
                self.volumeLabel.text = vol
                
            }
            

        }
        
        
        
    }

    func displayCharts(viewModel: ShowCoin.FetchChart.ViewModel) {
        self.refresher.endRefreshing()
        var lineChartEntries: [CandleChartDataEntry] = []
        var barChartEntries: [BarChartDataEntry] = []
        
        
        var startPrice: Double = 0.0
        var endPrice: Double = 0.0
        for (index, i) in viewModel.chartData.enumerated() {
//            let diceRoll = Int(arc4random_uniform(20) + 1)
            if index == 0 {
                startPrice = i.1
            } else if index == viewModel.chartData.count - 1{
                endPrice = i.1
            }
            
            let value =  CandleChartDataEntry(x: Double(index), shadowH: i.1, shadowL: i.2, open: i.3, close: i.4)
            
            let bar = BarChartDataEntry(x: Double(i.0), y: i.5)
            lineChartEntries.append(value)
            barChartEntries.append(bar)
            
        }
        
        let line1 = CandleChartDataSet(values: lineChartEntries, label: nil)
        var bar1 = BarChartDataSet(values: barChartEntries, label: nil)
        
        
//        scaling volume to be in between graph
//        barChartEntries = barChartEntries.map({
//            let scaled = ($0.y - bar1.yMin) / ( bar1.yMax - bar1.yMin)
//            let scaled1 = scaled * (line1.yMax - line1.yMin)/1.3333 + line1.yMin
////            print(scaled1)
//            return BarChartDataEntry(x: $0.x, y: scaled1)
//        })
//        lineChartEntries =
        bar1 = BarChartDataSet(values: barChartEntries, label: nil)
        
        
        
//        line1.colors = [self.percentLabel.textColor]
        if startPrice - endPrice < 0 {
//            line1.colors = [UIView.theGreen]
        } else {
//            line1.colors = [UIView.theRed]
        }
//        line1.drawCirclesEnabled = false
        line1.drawValuesEnabled = false
        line1.axisDependency = .left
        line1.increasingColor = UIView.theGreen
        line1.decreasingColor = UIView.theRed
        line1.increasingFilled = true
        line1.decreasingFilled = true
//        line1.neutralColor = UIColor.light
        line1.shadowColorSameAsCandle = true
        
//        line1.shadowColor = UIColor.darkGray
        
        bar1.axisDependency = .right
        bar1.drawValuesEnabled = false
        bar1.barBorderColor = .lightGray
        bar1.barBorderWidth = 1.0
        let lineData = CandleChartData(dataSet: line1)
        let barData = BarChartData(dataSet: bar1)
        
        let data: CombinedChartData = CombinedChartData()
        
        data.candleData = lineData
//        data.barData = barData
        
        
        
//        let data = LineChartData()
//        data.addDataSet(line1)
        
        
//        lineChart.
//        self.lineChart.autoScaleMinMaxEnabled = true
        let min = line1.yMin
        let max = line1.yMax
        self.lineChart.leftAxis.axisMaximum = max
        self.lineChart.leftAxis.axisMinimum = min
        
        self.lineChart.rightAxis.axisMaximum = max
        self.lineChart.rightAxis.axisMinimum = min
//        self.lineChart.rightAxis.yOffset = 50.0
        
        self.lineChart.data = data
        self.lineChart.animate(xAxisDuration: 0.2, easingOption: .linear)
        
//        self.lineChart.animate(xAxisDuration: 0.3, yAxisDuration: 0.3, easingOption: .linear)
        self.lineChart.notifyDataSetChanged()
        self.barChart.data = barData
        self.barChart.animate(yAxisDuration: 0.4, easingOption: .linear)
        
        if lineChartEntries.count == 0 {
            return
        }
        let ohlc: CandleChartDataEntry = self.lineChart.data?.dataSets.first!.entryForIndex(lineChartEntries.count - 1) as! CandleChartDataEntry
        self.chartOpenLabel.text = "O: \(ohlc.open)"
        self.chartHighLabel.text = "H: \(ohlc.high)"
        self.chartLowLabel.text = "L: \(ohlc.low)"
        self.chartCloseLabel.text = "C: \(ohlc.close)"
        
        self.displayCandlestick(open: startPrice, high: max, low: min, close: endPrice)
        
        let string: NSString = self.lineChart.rightAxis.getFormattedLabel(0) as NSString
        let font = self.lineChart.rightAxis.labelFont
        let width = string.size(attributes: [NSFontAttributeName: font]).width
        self.volumeChartOffset.constant = -1 * width
        self.view.layoutIfNeeded()
        
        
    }
    
//    func displayExchanges(viewModel: ShowCoin.FetchExchangesAndPair.ViewModel) {
//
////        self.exchangeButton.setTitle(viewModel.exchangeName, for: .normal)
////        self.firstExchangeButton.setTitleColor(UIColor.lightGray, for: .normal)
////        self.currencyButton.setTitle(viewModel.quote, for: .normal)
//        self.exchangeButton.setTitle(viewModel.exchangeName, for: .normal)
//        self.currencyButton.setTitle(viewModel.quote, for: .normal)
//        self.displayedExchange = viewModel.exchangeName.lowercased()
//        self.displayedQuote = viewModel.quote.lowercased()
//        if viewModel.exchangeName != "" {
//            transactionButtonsView.isHidden = false
//        }
////        print(viewModel.quotes)
//        self.quotes = viewModel.quotes
//        self.quotesCollectionView.reloadData()
//
//    }
}
extension ShowCoinViewController: UIGestureRecognizerDelegate {
    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
        if touch.view != nil && touch.view! != self.transactionButtonsView {
            return false
        } else {
            return true
        }
    }
    func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
        return true
    }
}

extension ShowCoinViewController: UICollectionViewDataSource {
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return self.displayedSelections.count
        
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "QuoteCell", for: indexPath) as! QuoteCollectionViewCell
        
        let index = indexPath.item
        cell.setCell(quote: self.displayedSelections[index])
        return cell
    }
    
}
extension ShowCoinViewController: UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        changeQuoteAndExchange(info: self.displayedSelections[indexPath.item])
        
    }
}

extension ShowCoinViewController: ChartViewDelegate {
    func chartValueSelected(_ chartView: ChartViewBase, entry: ChartDataEntry, highlight: Highlight) {
        let ohlc = entry as! CandleChartDataEntry
        self.chartOpenLabel.text = "O: \(ohlc.open)"
        self.chartHighLabel.text = "H: \(ohlc.high)"
        self.chartLowLabel.text = "L: \(ohlc.low)"
        self.chartCloseLabel.text = "C: \(ohlc.close)"
        
        self.priceLabel.text = "\(ohlc.close)"
        self.high24Label.text = "\(ohlc.high)"
        self.low24Label.text = "\(ohlc.low)"
        
        self.displayCandlestick(open: ohlc.open, high: ohlc.high, low: ohlc.low, close: ohlc.close)
        
    }
    
    
    func chartValueNothingSelected(_ chartView: ChartViewBase) {
//        let a: ChartDataEntry = chartView.data?.getFirstRight(dataSets: chartView.data)
        let ohlc: CandleChartDataEntry = chartView.data?.dataSets.first!.entryForIndex(chartView.data!.dataSets.first!.entryCount - 1) as! CandleChartDataEntry
        self.chartOpenLabel.text = "O: \(ohlc.open)"
        self.chartHighLabel.text = "H: \(ohlc.high)"
        self.chartLowLabel.text = "L: \(ohlc.low)"
        self.chartCloseLabel.text = "C: \(ohlc.close)"
        
        
//        self.percentLabel.text = "\(ohlc.close)"
        
    }
}

extension ShowCoinViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if scrollView == self.quotesCollectionView {
            return
        } else {
            self.dismissSelectionView()
        }
        
    }
    
}

