//
//  ShowCoinInteractor.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ShowCoinBusinessLogic
{
//    func doSomething(request: ShowCoin.Something.Request)
    func fetchCoin(request: ShowCoin.ShowCoin.Request)
    func fetchExchangesAndPair(request: ShowCoin.FetchExchangesAndPair.Request, completion: @escaping ()-> Void)
    func fetchHoldings(request: ShowCoin.FetchHoldings.Request)
}

protocol ShowCoinDataStore
{
    //var name: String { get set }
    var coin: Coin? { get set }
    
    var exchange: Exchange? { get set }
    
    var pair: Pair? { get set }
}

class ShowCoinInteractor: ShowCoinBusinessLogic, ShowCoinDataStore
{

    var presenter: ShowCoinPresentationLogic?
//    var worker: PortfolioWorker = PortfolioWorker.sharedInstance
    var coinWorker: CoinWorker = CoinWorker()
    var portfolioWorker: PortfolioWorker = PortfolioWorker.sharedInstance
    var coin: Coin?
    var exchange: Exchange?
    var pair: Pair?
    
    // MARK: Do something
    
    func fetchHoldings(request: ShowCoin.FetchHoldings.Request) {
        if let asset = portfolioWorker.portfolio.find(coin: self.coin!.symbol) {
            let marketValue: Double = asset.marketValue
//            let initValue: Double = portfolioWorker.portfolio.initialValue(of: self.coin!.symbol)!
            let initValue: Double = asset.initialValue
            let amount: Double = asset.amountHeld
            let resp = ShowCoin.FetchHoldings.Response(marketValue: marketValue, initialValue: initValue, amount: amount, totalGain: marketValue-initValue, exists: true)
            presenter?.presentHoldings(response: resp)
            
        } else {
            let resp = ShowCoin.FetchHoldings.Response(marketValue: 0.0, initialValue: 0.0, amount: 0.0, totalGain: 0.0, exists: false)
            presenter?.presentHoldings(response: resp)
        }
        
    }
    
    func fetchCoin(request: ShowCoin.ShowCoin.Request) {
        
        
        if request.exchange != nil && coin?.exchanges[request.exchange!] != nil {
            
            let exchange = coin!.exchanges[request.exchange!]!
            
            self.exchange = exchange
            
            if self.exchange?.pairs[self.coin!.symbol]?[request.quote!] != nil {
                self.pair = self.exchange?.pairs[self.coin!.symbol]![request.quote!]
                
                let resp = ShowCoin.ShowCoin.Response(price: self.pair!.price!, percent: self.pair!.percentChange24, volume: self.pair!.volume24, name: self.coin!.name, symbol: self.coin!.symbol, quote: request.quote!)
                self.presenter?.presentCoin(response: resp)
                

            }
            else {
                self.exchange = coin!.defaultExchange
                self.pair = self.coin!.defaultPair
                let resp = ShowCoin.ShowCoin.Response(price: self.pair!.price!, percent: self.pair!.percentChange24, volume: self.pair!.volume24, name: self.coin!.name, symbol: self.coin!.symbol, quote: self.pair!.quote)
                self.presenter?.presentCoin(response: resp)
            }
//            for pairs in exchange.pairs {
//                for pair in pairs.value {
//                    if pair.quote == request.quote! {
//                        self.pair = pair
//                        
//                        let resp = ShowCoin.ShowCoin.Response(price: self.pair!.price!, percent: self.pair!.percentChange24, volume: self.pair!.volume24, name: self.coin!.name, symbol: self.coin!.symbol, quote: request.quote!)
//                        self.presenter?.presentCoin(response: resp)
//                        
//                        //                    coinWorker.fetchPair(pair: pair.value, exchange: exchange, completion: { (newPair) in
//                        //
//                        //
//                        //                    })
//                        return
//                    }
//                }
//                
//            }
            
            
//            coinWorker.fetchPair(pair: exchange.pairs.first!.value, exchange: exchange, completion: { (newPair) in
//                let resp = ShowCoin.ShowCoin.Response(price: newPair.price!, percent: newPair.percentChange24, volume: newPair.volume24, name: self.coin!.name, symbol: self.coin!.symbol, quote: exchange.pairs.first!.value.quote)
//                self.presenter?.presentCoin(response: resp)
//                
//            })
            
            
        } else {
            self.exchange = coin!.exchanges["CoinMarketCap"]!
            self.pair = self.coin!.defaultPair
            let response = ShowCoin.ShowCoin.Response(price: self.pair!.price, percent: self.pair!.percentChange24!, volume: self.pair!.volume24, name: self.coin!.name, symbol: self.coin!.symbol,quote: "usd")
            self.presenter?.presentCoin(response: response)
        }
        
        
        
    }
    func fetchExchangesAndPair(request: ShowCoin.FetchExchangesAndPair.Request, completion: @escaping  () -> Void) {
        MarketWorker.sharedInstance.exchangeInfoGroup.notify(queue: .main, execute: {
            let quotes = self.coin!.allQuotes()
            if let coin = MarketWorker.sharedInstance.coinCollection[self.coin!.symbol] {
                let exchange = coin.defaultExchange
                
                let quote = coin.defaultPair.quote
                let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: exchange.name, quote: quote, quotes: quotes)
                self.presenter?.presentExchangesAndPair(response: resp)
                completion()
            } else {
                let exchange = self.coin!.defaultExchange
                let quote = self.coin!.defaultPair.quote
                let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: exchange.name, quote: quote, quotes: quotes)
                self.presenter?.presentExchangesAndPair(response: resp)
                completion()
            }
            
        })
        
        
        
        
//        coinWorker.fetchExchanges(coin: self.coin!, completion: { (newCoin) in
//            self.coin = newCoin
//            MarketWorker.sharedInstance.coinCollection[self.coin!.symbol] = newCoin
//            var exchange = self.coin!.exchanges.first!.value
//            //            for (key, exchange) in self.coin!.exchanges {
//            //                for (n, pair) in exchange.pairs.enumerated() {
//            //                    self.coin!.exchanges[key]!.pairs[n].price = self.coin?.overallInfo?.price!
//            //                }
//            //            }
//            
//            let quote = exchange.pairs.first!.quote
//            let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: exchange.name, quote: quote)
//            self.presenter?.presentExchangesAndPair(response: resp)
////            let response = ShowCoin.ShowCoin.Response(price: self.coin!.overallInfo?.price, percent: self.coin!.overallInfo?.percentChange24!, volume: self.coin!.overallInfo?.volume24, name: self.coin!.name, symbol: self.coin!.symbol, exchangeName: self.coin!.exchanges.first!.value.name, quote: quote)
////            self.presenter?.presentCoin(response: response)
//            completion()
//        },error: {
//            if let coin = MarketWorker.sharedInstance.coinCollection[self.coin!.symbol] {
//                self.coin = coin
//                var exchange = self.coin!.exchanges.first!.value
//                let quote = exchange.pairs.first!.quote
//                let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: exchange.name, quote: quote)
//                self.presenter?.presentExchangesAndPair(response: resp)
//            } else {
//                let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: "", quote: "usd")
//                self.presenter?.presentExchangesAndPair(response: resp)
//            }
////            var exchange = self.coin!.exchanges.first!.value
////            let quote = exchange.pairs.first!.quote
////            let resp = ShowCoin.FetchExchangesAndPair.Response(exchangeName: exchange.name, quote: quote)
////            self.presenter?.presentExchangesAndPair(response: resp)
//
//            completion()
//        })
    }
    
    
    
}
