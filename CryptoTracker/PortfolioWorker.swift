//
//  PortfolioWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RealmSwift

class PortfolioWorker
{
    static let sharedInstance = PortfolioWorker()
    
    var portfolio: Portfolio!
    
    
    
    func setup() {
        let realm = try! Realm()
        if let p = realm.object(ofType: Portfolio.self, forPrimaryKey: "Default") {
            self.portfolio = p
        } else {
            let p = Portfolio()
            p.name = "Default"
            try! realm.write {
                realm.add(p, update: true)
            }
            self.portfolio = p
        }
        
        self.portfolio.cleanWatchlist()
    }
    
    func addToWatchlist(coin: Coin) {
        let realm = try! Realm()
        if !portfolio.watchlist.contains(coin) {
            try! realm.write {
                portfolio.watchlist.append(coin)
            }
        }
        self.portfolio.cleanWatchlist()
    }
    func removeFromWatchlist(coin: Coin) {
        self.portfolio.removeFromWatchlist(coin: coin)
    }
    
    func marketValue() -> Double {
        return portfolio.value
        let market = MarketWorker.sharedInstance
        var val = 0.0
        for asset in self.portfolio.assets {
            if asset.coin!.coinType == Coin.CoinType.Fiat.rawValue {
                val += asset.amountHeld
            } else {
//                let coin = market.coinCollection[]
                val += asset.amountHeld * asset.coin!.defaultPair!.price.value!
            }

        }
        return val
    }
    
    func addTransaction(pair: Pair, price: Double, amount: Double, isBuy: Bool, exchange: String) {
        var type: Transaction.OrderType = .Buy
        if !isBuy {
            type = .Sell
        }
        let transaction = Transaction()
        transaction.pair = pair
        transaction.price = price
        transaction.fiatPrice = pair.base!.defaultPair!.price.value!
        
        if pair.quoteSymbol == "usd" {
            transaction.fiatPrice = price
        } else {
            transaction.btcPrice = pair.base!.btcPair(on: "CoinMarketCap")!.price.value!
        }
        
        
        transaction.amount = amount
        transaction.orderType = type.rawValue
        
        let total = price * amount
        
        let realm = try! Realm()
        
        var flag = false
        try! realm.write {
            var baseAsset: Asset
            var quoteAsset: Asset
            if let q = self.portfolio.assets.filter("coin.symbol = %@", pair.quoteSymbol).first {
                quoteAsset = q
            } else {
                let asset = Asset()
                asset.coin = pair.quote!
                quoteAsset = asset
                realm.add(quoteAsset)
                portfolio.assets.append(quoteAsset)
                
            }
            if let b = self.portfolio.assets.filter("coin.symbol = %@", pair.baseSymbol).first {
                baseAsset = b
            } else {
                let asset = Asset()
                asset.coin = pair.base!
                baseAsset = asset
                realm.add(baseAsset)
                portfolio.assets.append(baseAsset)
                
            }
            print(baseAsset.coin!.name)
            let tempTransac = Transaction()
            switch type {
            case .Buy:
                if quoteAsset.amountHeld < total {
                    let amountToGet = total - quoteAsset.amountHeld
                    
                    tempTransac.amount = amountToGet
                    if quoteAsset.coin!.symbol == "usd" {
                        tempTransac.fiatPrice = 1.0
//                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    } else {
                        tempTransac.fiatPrice = pair.quote!.defaultPair!.price.value!
                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    }
                    
                    
                    tempTransac.isInitialFunding = true
                    quoteAsset.buys.append(tempTransac)
                    realm.add(tempTransac)
                    
                }
            case .Sell:
                if baseAsset.amountHeld < transaction.amount {
                    let amountToGet = transaction.amount - baseAsset.amountHeld
                    
                    tempTransac.amount = amountToGet
                    if quoteAsset.coin!.symbol == "usd" {
                        tempTransac.fiatPrice = 1.0
                        //                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    } else {
                        tempTransac.fiatPrice = pair.quote!.defaultPair!.price.value!
                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    }
                    tempTransac.btcPrice = pair.base!.btcPair(on: "CoinMarketCap")!.price.value!
                    tempTransac.isInitialFunding = true
                    baseAsset.buys.append(tempTransac)
                    realm.add(tempTransac)
                }
            }
        
            
            
            
            
            realm.add(transaction)
            
            
            
            switch type {
            case .Buy:
                baseAsset.buys.append(transaction)
                quoteAsset.sells.append(transaction)
            case .Sell:
                baseAsset.sells.append(transaction)
                quoteAsset.buys.append(transaction)
            }
            baseAsset.updateAmount()
            quoteAsset.updateAmount()
            
        }
        
        let exchange = realm.object(ofType: Exchange.self, forPrimaryKey: exchange)!
        
        
        
    }
    
//    func addTransaction(pair: Pair, price: Double, amount: Double, isBuy: Bool, exchange: String) {
//        var type: Transaction.OrderType = .Buy
//        if !isBuy {
//            type = .Sell
//        }
//        
//        let transaction = Transaction(pair: pair, price: price, amount: amount, type: type, exchange: exchange)
//        let sellTransaction = Transaction(pair: pair, price: price, amount: price*amount, type: isBuy ? .Sell : .Buy, exchange: exchange)
//        let base = MarketWorker.sharedInstance.coinCollection[pair.base]!
//        var found = false
//        var quoteFound = false
//        for each in self.portfolio.assets {
//            if each.coin.symbol == base.symbol {
////                let asset = each
//                if transaction.orderType == .Sell {
//                    if each.amountHeld - transaction.amount < 0 {
//                        let tempTrans = Transaction(pair: pair, price: price, amount: (each.amountHeld-transaction.amount) * -1, type: .Buy, exchange: exchange)
////                        PortfolioWorker.sharedInstance.portfolio.initialValue += (each.amountHeld-transaction.amount) * -1
//                        tempTrans.notes = "Capital Injection"
//                        tempTrans.isInitialFunding = true
//                        each.addTransaction(transaction: tempTrans)
//                        
//                    }
//                }
//                
//                each.addTransaction(transaction: transaction)
//                found = true
//                break
//            }
//            
//        }
//        for each in self.portfolio.assets {
//            if each.coin.symbol == pair.quote {
////                let asset = each
//                if sellTransaction.orderType == .Sell {
//                    if each.amountHeld - sellTransaction.amount < 0 {
//                        let tempTrans = Transaction(pair: pair, price: price, amount: (each.amountHeld-sellTransaction.amount) * -1, type: .Buy, exchange: exchange)
//                        tempTrans.notes = "Capital Injection"
//                        tempTrans.isInitialFunding = true
////                        PortfolioWorker.sharedInstance.portfolio.initialValue += (each.amountHeld-sellTransaction.amount) * -1
//                        each.addTransaction(transaction: tempTrans)
//                    }
//                }
//                each.addTransaction(transaction: sellTransaction)
//                quoteFound = true
//                break
//            }
//        }
//        if !found {
//            let asset = Asset(coin: base, type: .Crypto)
//            
//            if transaction.orderType == .Sell {
//                if asset.amountHeld - transaction.amount < 0 {
//                    let tempTrans = Transaction(pair: pair, price: price, amount: (asset.amountHeld-transaction.amount) * -1, type: .Buy, exchange: exchange)
////                    PortfolioWorker.sharedInstance.portfolio.initialValue += (asset.amountHeld-transaction.amount) * -1
//                    tempTrans.notes = "Capital Injection"
//                    tempTrans.isInitialFunding = true
//                    asset.addTransaction(transaction: tempTrans)
//                }
//            }
//            
//            asset.addTransaction(transaction: transaction)
//            self.portfolio.assets.append(asset)
//        }
//        if !quoteFound {
//            let asset: Asset
//            if MarketWorker.sharedInstance.coinCollection[pair.quote] != nil {
//                let coin = MarketWorker.sharedInstance.coinCollection[pair.quote]!
//                asset = Asset(coin: coin, type: .Crypto)
//                
//            }
//            else {
//                let coin = Coin(name: pair.quote, symbol: pair.quote)
//                var temp: [String: [String: Pair]] = [:]
//                temp[pair.quote] = [:]
//                var pair = Pair(base: coin.symbol, quote: pair.quote, pair: "\(pair.quote)\(pair.quote)")
//                pair.price = 1.0
//                pair.percentChange24 = 0.0
//                temp[pair.quote]![pair.quote] = pair
//                let exchange = Exchange(pairs: temp, name: "CoinMarketCap")
//                coin.exchanges["CoinMarketCap"] = exchange
//                asset = Asset(coin: coin, type: .Fiat)
//                
//            }
//            if sellTransaction.orderType == .Sell {
//                if asset.amountHeld - sellTransaction.amount < 0 {
//                    let tempTrans = Transaction(pair: pair, price: price, amount: (asset.amountHeld-sellTransaction.amount) * -1, type: .Buy, exchange: exchange)
//                    tempTrans.notes = "Capital Injection"
//                    tempTrans.isInitialFunding = true
////                    PortfolioWorker.sharedInstance.portfolio.initialValue += (asset.amountHeld-sellTransaction.amount) * -1
//                    asset.addTransaction(transaction: tempTrans)
//                }
//            } else {
//                
//            }
//            
//            asset.addTransaction(transaction: sellTransaction)
//            self.portfolio.assets.append(asset)
//            
//        }
//        do {
//            try savePortfolio()
//        } catch {
//            print("not save")
//        }
        
        
//    }
    var chartDataWaitGroup: DispatchGroup = DispatchGroup()
    
    func fetchWatchlistCharts(force: Bool, completion: @escaping (String, [(Int,Double, Double, Double, Double, Double)]) -> Void) {
        let coinWorker = CoinWorker()
        
        for (index, coin) in self.portfolio.watchlist.enumerated() {
            
            coinWorker.fetchChart(of: coin.defaultPair!, from: coin.defaultPair!.exchange!, for: .Day, completion: { (data) in
                var newArr: [(Int,Double, Double, Double, Double, Double)] = data
                
                
                let p = Pair()
                let newData = p.time(newArr, duration: .Day)
                completion(coin.symbol, newData)
            })
            
        }
    }
    
    func fetchAssetCharts(force: Bool, completion: @escaping (String, [(Int,Double, Double, Double, Double, Double)]) -> Void) {
        let coinWorker = CoinWorker()

        for (index, asset) in self.portfolio.assets.enumerated() {
            if asset.coin?.coinType != Coin.CoinType.Fiat.rawValue {
                
                    coinWorker.fetchChart(of: asset.coin!.defaultPair!, from: asset.coin!.defaultPair!.exchange!, for: .Day, completion: { (data) in
                        var newArr: [(Int,Double, Double, Double, Double, Double)] = data


                        let p = Pair()
                        let newData = p.time(newArr, duration: .Day)
                        completion(asset.coin!.symbol, newData)
                    })
                


            }

        }


//
        
        
    }
    func constructPortfolioChart() -> [(Int, Double, Double, Double, Double, Double)] {
//        if self.portfolio.assets.count == 0 {
//            return []
//        }
//        var totalData: [(Int, Double, Double, Double, Double, Double)] = Array(repeating: (0,0,0,0,0,0), count: self.portfolio.assets[0].coin.defaultChartData.day!.count)
////        for asset in self.portfolio.assets {
////
////        }
//
//        let coins = self.portfolio.assets.filter({ $0.assetType != .Fiat })
//        let amounts = coins.map({ $0.amountHeld })
//        let charts = coins.map({$0.coin.defaultChartData.day!})
//        let zipped = zip(amounts,charts)
//        let data = zipped.reduce((0.0,totalData), { (arg1:  (Double, [(Int, Double, Double, Double, Double, Double)]), arg2:  (Double, [(Int, Double, Double, Double, Double, Double)]) ) in
//
//            return (arg2.0, zip(arg1.1, arg2.1).map({
//
//                let x = $0.1.0
//                let price = $0.1.4
//                let amount = arg2.0
//                let y = $0.0.1 + price * amount
//                let data: (Int, Double, Double, Double, Double, Double) = (x,y,0.0,0.0,0.0,0.0)
//                return data
//            }))
////            zip($0.0, $1)
//
//        })
//        return data.1
        return []
        
    }
    
    
    
    
    
    init() {
        
        
    }
    
}
