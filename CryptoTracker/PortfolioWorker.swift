//
//  PortfolioWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RealmSwift

class PortfolioWorker
{
    static let sharedInstance = PortfolioWorker()
    
    var portfolio: Portfolio!
    var allPortfolios: Results<Portfolio>!
    
    
    
    func setup() {
        let realm = try! Realm()
        if let p = realm.object(ofType: Portfolio.self, forPrimaryKey: "Default") {
            self.portfolio = p
        } else {
            let p = Portfolio()
            p.name = "Default"
            try! realm.write {
                realm.add(p, update: true)
            }
            self.portfolio = p
//            self.portfolio.addToWatchlist(pair: realm.object(ofType: Pair.self, forPrimaryKey: "btc-usd-CCCAGG")!)
        }
        var portfolios = realm.objects(Portfolio.self)
        
        self.allPortfolios = portfolios
        self.fetchAllPrices(completion: {}, {})
        
        
//        self.portfolio.cleanWatchlist()
    }
    
    func addToWatchlist(pair: Pair) {
        let realm = try! Realm()
        if portfolio.watchlist.filter("id = %@", pair.id).first == nil{
            try! realm.write {
                portfolio.watchlist.append(pair)
            }
        }
//        self.portfolio.cleanWatchlist()
    }
    func removeFromWatchlist(pair: Pair) {
        self.portfolio.removeFromWatchlist(pair: pair)
    }
    
    var allPricesWaitGroup: DispatchGroup = DispatchGroup()
    
    func fetchAllPrices(completion: @escaping () -> Void, _ error: @escaping () -> Void) {
        for p in self.allPortfolios {
            
            let quotes = ["usd", "btc"] + p.watchlist.map({ (c) -> String in
                c.quoteSymbol
            })
            let bases: [String] = p.assets.filter("coin.coinType != 'fiat'").map { (a) -> String in
                a.coin!.symbol
                } + p.watchlist.map({ (c) -> String in
                    c.baseSymbol
                })
            let exchange = Exchange()
            exchange.name = "CCCAGG"
            let coinWorker = CoinWorker()
            allPricesWaitGroup.enter()
            coinWorker.fetchMultiple(bases: bases, quotes: quotes, exchange: exchange, completion: {
                
                completion()
                
                self.allPricesWaitGroup.leave()
            }, {
                error()
                self.allPricesWaitGroup.leave()
            })
        }
        
    }
    
    func marketValue() -> Double {
        return portfolio.marketValue
        
    }
    
    func addTransaction(pair: Pair, price: Double, amount: Double, isBuy: Bool, exchange: String) -> Bool {
        var type: Transaction.OrderType = .Buy
        if !isBuy {
            type = .Sell
        }
        let transaction = Transaction()
        transaction.pair = pair
        transaction.price = price
        if let fiatPrice = pair.base?.defaultPair?.price.value {
            transaction.fiatPrice = fiatPrice
        } else {
            return false
        }
        
        
        if pair.quoteSymbol == "usd" {
            transaction.fiatPrice = price
        } else {
            transaction.btcPrice = pair.base!.btcPair(on: "CoinMarketCap")!.price.value!
        }
        
        
        transaction.amount = amount
        transaction.orderType = type.rawValue
        transaction.date = Date()
        let total = price * amount
        
        let realm = try! Realm()
        
        var flag = false
        try! realm.write {
            realm.add(transaction)
            transaction.pair = pair
            var baseAsset: Asset
            var quoteAsset: Asset
            if let q = self.portfolio.assets.filter("coin.symbol = %@", pair.quoteSymbol).first {
                quoteAsset = q
            } else {
                let asset = Asset()
                asset.coin = pair.quote!
                quoteAsset = asset
                realm.add(quoteAsset)
                portfolio.assets.append(quoteAsset)
                
            }
            if let b = self.portfolio.assets.filter("coin.symbol = %@", pair.baseSymbol).first {
                baseAsset = b
            } else {
                let asset = Asset()
                asset.coin = pair.base!
                baseAsset = asset
                realm.add(baseAsset)
                portfolio.assets.append(baseAsset)
                
            }
//            print(baseAsset.coin!.name)
            let tempTransac = Transaction()
            switch type {
            case .Buy:
                if quoteAsset.amountHeld < total {
                    let amountToGet = total - quoteAsset.amountHeld
                    
                    tempTransac.amount = amountToGet
                    if quoteAsset.coin!.symbol == "usd" {
                        tempTransac.fiatPrice = 1.0
//                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    } else {
                        tempTransac.fiatPrice = pair.quote!.defaultPair!.price.value!
                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    }
                    
                    
                    tempTransac.isInitialFunding = true
                    quoteAsset.buys.append(tempTransac)
                    realm.add(tempTransac)
                    
                }
            case .Sell:
                if baseAsset.amountHeld < transaction.amount {
                    let amountToGet = transaction.amount - baseAsset.amountHeld
                    
                    tempTransac.amount = amountToGet
                    if quoteAsset.coin!.symbol == "usd" {
                        tempTransac.fiatPrice = 1.0
                        //                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CoinMarketCap")!.price.value!
                    } else {
                        tempTransac.fiatPrice = pair.quote!.defaultPair!.price.value!
                        tempTransac.btcPrice = pair.quote!.btcPair(on: "CCCAGG")!.price.value!
                    }
                    tempTransac.btcPrice = pair.base!.btcPair(on: "CCCAGG")!.price.value!
                    tempTransac.isInitialFunding = true
                    baseAsset.buys.append(tempTransac)
                    realm.add(tempTransac)
                }
            }
        
            
            
            
            
            
            
            
            
            switch type {
            case .Buy:
                baseAsset.buys.append(transaction)
                quoteAsset.sells.append(transaction)
            case .Sell:
                baseAsset.sells.append(transaction)
                quoteAsset.buys.append(transaction)
            }
            
            baseAsset.updateAmount()
            quoteAsset.updateAmount()
            
        }
        
        
//        let exchange = realm.object(ofType: Exchange.self, forPrimaryKey: exchange)!
        
        
        return true
    }
    

    var chartDataWaitGroup: DispatchGroup = DispatchGroup()
    
    func fetchWatchlistCharts(force: Bool, completion: @escaping (String, String, [(Int,Double, Double, Double, Double, Double)]) -> Void, _ error: @escaping () -> Void) {
        let coinWorker = CoinWorker()
        
        for (index, coin) in self.portfolio.watchlist.enumerated() {
            PortfolioWorker.sharedInstance.chartDataWaitGroup.enter()
            if coin.exchange == nil {
                print(coin.exchangeName)
            }
            let realm = try! Realm()
            coinWorker.fetchChart(of: coin, from: coin.exchange ?? realm.objects(Exchange.self).filter("name = 'CCCAGG'").first!, for: .Day, completion: { (data) in
                var newArr: [(Int,Double, Double, Double, Double, Double)] = data
                
                PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
                let p = Pair()
                let newData = p.time(newArr, duration: .Day)
                completion(coin.baseSymbol, coin.quoteSymbol, newData)
                
                
            }, {
                PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
                error()
                
            })
            
        }
    }
    
    func fetchAssetCharts(force: Bool, completion: @escaping (String, String, [(Int,Double, Double, Double, Double, Double)]) -> Void, _ error: @escaping () -> Void) {
        let coinWorker = CoinWorker()
        let assets = self.portfolio.assets.filter("coin.coinType != %@", Coin.CoinType.Fiat.rawValue)
        for asset in assets {
            PortfolioWorker.sharedInstance.chartDataWaitGroup.enter()
            coinWorker.fetchChart(of: asset.coin!.defaultPair!, from: asset.coin!.defaultPair!.exchange!, for: .Day, completion: { (data) in
                var newArr: [(Int,Double, Double, Double, Double, Double)] = data
                
                PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
                let p = Pair()
                let newData = p.time(newArr, duration: .Day)
                completion(asset.coin!.symbol, "usd", newData)
                
            }, {
                PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
                error()
                
            })
        }
//        let objects = self.portfolio.assets.filter("coin.coinType != %@", Coin.CoinType.Fiat.rawValue).map({ (asset) -> DispatchWorkItem in
//            return DispatchWorkItem(block: {
//                PortfolioWorker.sharedInstance.chartDataWaitGroup.enter()
//                coinWorker.fetchChart(of: asset.coin!.defaultPair!, from: asset.coin!.defaultPair!.exchange!, for: .Day, completion: { (data) in
//                    var newArr: [(Int,Double, Double, Double, Double, Double)] = data
//
//                    PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
//                    let p = Pair()
//                    let newData = p.time(newArr, duration: .Day)
//                    completion(asset.coin!.symbol, "usd", newData)
//
//                })
//            })
//        })
//        objects.map { (d) -> Void in
//            d.perform()
//        }
        
            
            
        
            
        
//        for (index, asset) in self.portfolio.assets.enumerated() {
//            if asset.coin?.coinType != Coin.CoinType.Fiat.rawValue {
//                PortfolioWorker.sharedInstance.chartDataWaitGroup.enter()
//                coinWorker.fetchChart(of: asset.coin!.defaultPair!, from: asset.coin!.defaultPair!.exchange!, for: .Day, completion: { (data) in
//                    var newArr: [(Int,Double, Double, Double, Double, Double)] = data
//
//                    PortfolioWorker.sharedInstance.chartDataWaitGroup.leave()
//                    let p = Pair()
//                    let newData = p.time(newArr, duration: .Day)
//                    completion(asset.coin!.symbol, "usd", newData)
//
//                })
//
//
//
//            }
//
//        }


//
        
        
    }
    func constructPortfolioChart() -> [(Int, Double, Double, Double, Double, Double)] {
//        if self.portfolio.assets.count == 0 {
//            return []
//        }
//        var totalData: [(Int, Double, Double, Double, Double, Double)] = Array(repeating: (0,0,0,0,0,0), count: self.portfolio.assets[0].coin?.defaultPair.
//            defaultChartData.day!.count)
////        for asset in self.portfolio.assets {
////
////        }
//
//        let coins = self.portfolio.assets.filter({ $0.assetType != .Fiat })
//        let amounts = coins.map({ $0.amountHeld })
//        let charts = coins.map({$0.coin.defaultChartData.day!})
//        let zipped = zip(amounts,charts)
//        let data = zipped.reduce((0.0,totalData), { (arg1:  (Double, [(Int, Double, Double, Double, Double, Double)]), arg2:  (Double, [(Int, Double, Double, Double, Double, Double)]) ) in
//
//            return (arg2.0, zip(arg1.1, arg2.1).map({
//
//                let x = $0.1.0
//                let price = $0.1.4
//                let amount = arg2.0
//                let y = $0.0.1 + price * amount
//                let data: (Int, Double, Double, Double, Double, Double) = (x,y,0.0,0.0,0.0,0.0)
//                return data
//            }))
////            zip($0.0, $1)
//
//        })
//        return data.1
        return []
////
////    }
        return []
    }
    
    
    
    
    
    
}
