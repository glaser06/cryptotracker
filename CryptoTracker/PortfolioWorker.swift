//
//  PortfolioWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/25/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Cereal

class PortfolioWorker
{
    static let sharedInstance = PortfolioWorker()
    
    var portfolio: Portfolio = Portfolio()
    
    func addTransaction(pair: Pair, price: Double, amount: Double, isBuy: Bool) {
        var type: Transaction.OrderType = .Buy
        if !isBuy {
            type = .Sell
        }
        
        let transaction = Transaction(pair: pair, price: price, amount: amount, type: type)
        let sellTransaction = Transaction(pair: pair, price: price, amount: price*amount, type: isBuy ? .Sell : .Buy)
        let base = MarketWorker.sharedInstance.coinCollection[pair.base]!
        var found = false
        var quoteFound = false
        for each in self.portfolio.assets {
            if each.coin.symbol == base.symbol {
//                let asset = each
                if transaction.orderType == .Sell {
                    if each.amountHeld - transaction.amount < 0 {
                        let tempTrans = Transaction(pair: pair, price: price, amount: (each.amountHeld-transaction.amount) * -1, type: .Buy)
//                        PortfolioWorker.sharedInstance.portfolio.initialValue += (each.amountHeld-transaction.amount) * -1
                        tempTrans.notes = "Capital Injection"
                        tempTrans.isInitialFunding = true
                        each.addTransaction(transaction: tempTrans)
                        
                    }
                }
                
                each.addTransaction(transaction: transaction)
                found = true
                break
            }
            
        }
        for each in self.portfolio.assets {
            if each.coin.symbol == pair.quote {
//                let asset = each
                if sellTransaction.orderType == .Sell {
                    if each.amountHeld - sellTransaction.amount < 0 {
                        let tempTrans = Transaction(pair: pair, price: price, amount: (each.amountHeld-sellTransaction.amount) * -1, type: .Buy)
                        tempTrans.notes = "Capital Injection"
                        tempTrans.isInitialFunding = true
//                        PortfolioWorker.sharedInstance.portfolio.initialValue += (each.amountHeld-sellTransaction.amount) * -1
                        each.addTransaction(transaction: tempTrans)
                    }
                }
                each.addTransaction(transaction: sellTransaction)
                quoteFound = true
                break
            }
        }
        if !found {
            let asset = Asset(coin: base, type: .Crypto)
            
            if transaction.orderType == .Sell {
                if asset.amountHeld - transaction.amount < 0 {
                    let tempTrans = Transaction(pair: pair, price: price, amount: (asset.amountHeld-transaction.amount) * -1, type: .Buy)
//                    PortfolioWorker.sharedInstance.portfolio.initialValue += (asset.amountHeld-transaction.amount) * -1
                    tempTrans.notes = "Capital Injection"
                    tempTrans.isInitialFunding = true
                    asset.addTransaction(transaction: tempTrans)
                }
            }
            
            asset.addTransaction(transaction: transaction)
            self.portfolio.assets.append(asset)
        }
        if !quoteFound {
            let asset: Asset
            if MarketWorker.sharedInstance.coinCollection[pair.quote] != nil {
                let coin = MarketWorker.sharedInstance.coinCollection[pair.quote]!
                asset = Asset(coin: coin, type: .Crypto)
                
            }
            else {
                let coin = Coin(name: pair.quote, symbol: pair.quote)
                var temp: [String: [String: Pair]] = [:]
                temp[pair.quote] = [:]
                var pair = Pair(base: coin, quote: pair.quote, pair: "\(pair.quote)\(pair.quote)")
                pair.price = 1.0
                pair.percentChange24 = 0.0
                temp[pair.quote]![pair.quote] = pair
                let exchange = Exchange(pairs: temp, name: "CoinMarketCap")
                coin.exchanges["CoinMarketCap"] = exchange
                asset = Asset(coin: coin, type: .Fiat)
                
            }
            if sellTransaction.orderType == .Sell {
                if asset.amountHeld - sellTransaction.amount < 0 {
                    let tempTrans = Transaction(pair: pair, price: price, amount: (asset.amountHeld-sellTransaction.amount) * -1, type: .Buy)
                    tempTrans.notes = "Capital Injection"
                    tempTrans.isInitialFunding = true
//                    PortfolioWorker.sharedInstance.portfolio.initialValue += (asset.amountHeld-sellTransaction.amount) * -1
                    asset.addTransaction(transaction: tempTrans)
                }
            } else {
                
            }
            
            asset.addTransaction(transaction: sellTransaction)
            self.portfolio.assets.append(asset)
            
        }
        do {
            try savePortfolio()
        } catch {
            print("not save")
        }
        
        
    }
    
    func savePortfolio() throws {
        
        let portfolio: Portfolio = PortfolioWorker.sharedInstance.portfolio
        
        
        var encoder = CerealEncoder()
//        try encoder.encode(portfolio, forKey: "portfolio")
        try encoder.encode(portfolio, forKey: "portfolio")
        let data = encoder.toData()
//                let decoder = try CerealDecoder(data: data)
        
        let p: Portfolio = try CerealDecoder(data: data).decodeCereal(key: "portfolio")!
        print(p.assets.count)
        UserDefaults.standard.set(data, forKey: "portfolio")
        UserDefaults.standard.synchronize()
        
    }
    func unpackPortfolio(_ completion: ((Portfolio) -> Void)?) throws {
        if let data = UserDefaults.standard.data(forKey: "portfolio") {
            let p: Portfolio = try CerealDecoder(data: data).decodeCereal(key: "portfolio")!
            if let c = completion {
                c(p)
            }
            
        }
        
    }
    
    func updateAssetPrices() {
//        for asset in self.portfolio.assets {
//            asset.currentPrice = 1.0
//        }
    }
    
    init() {
        do {
            try self.unpackPortfolio({ (p) in
                self.portfolio = p
            })
        } catch {
            
        }
        
    }
    
}
