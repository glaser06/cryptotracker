//
//  MarketWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/23/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftyJSON
import Cereal
import RealmSwift

class MarketWorker
{
    let marketService = CoinMarketCapAPI()
    let exchangeService = CryptowatchAPI()
    let bigService = CryptocompareAPI()
    
    let exchangeInfoGroup = DispatchGroup()
    
    
    func retrieveCoins(completion: (() -> Void)?) {
        var realm = try! Realm()
        var usd: Coin = Coin()
        
        usd.name = "US Dollar".lowercased()
        usd.symbol = "usd"
        usd.coinType = Coin.CoinType.Fiat.rawValue
        if let u = realm.object(ofType: Coin.self, forPrimaryKey: "usd") {
            usd = u
        }
        
        
        marketService.getCoinInfo(completion: { (json) in
            realm = try! Realm()
            
            let coinmarketcap = Exchange()
            coinmarketcap.name = "CoinMarketCap"
            try! realm.write {
                
                
//                fix this
                
                for data in json {
                    let name: String = data.1["name"].stringValue.lowercased()
                    let symbol: String = data.1["symbol"].string!.lowercased()
                    let cap: Double = Double(data.1["market_cap_usd"].stringValue)!
                    let price: Double = Double(data.1["price_usd"].string!)!
                    let percent: Double
                    if let temp = data.1["percent_change_24h"].string {
                        percent = Double(temp)!
                    } else {
                        percent = 0.0
                    }
                    let volume = Double(data.1["24h_volume_usd"].stringValue)
                    
                    var coin: Coin = Coin()
                    var pair = Pair()
                    coin.name = name
                    coin.symbol = symbol
                    coin.coinType = Coin.CoinType.Crypto.rawValue
                    if let c = realm.object(ofType: Coin.self, forPrimaryKey: symbol) {
                        coin = c
                        
                    } else {
                        realm.add(coin, update: true)
                    }
                    
                    pair.setAll(base: coin, quote: usd, exc: coinmarketcap)
                    if let p = coin.defaultPair {
                        pair = p
                    } else {
                        coin.pairs.append(pair)
                        realm.add(pair, update: true)
                    }

                    pair.price.value = price
                    pair.marketCap.value = cap
                    pair.volume.value = volume
                    pair.percentChange.value = percent
                    
                    
                    
                    
//              ************ add quote somehow **************
                    usd.quotes.append(pair)
//                    **********************
                    coinmarketcap.pairs.append(pair)
                    
                    
                    
                     
                    print(coin.name + "-" + name)
                    
                    
                }
                realm.add(usd, update: true)
                realm.add(coinmarketcap, update: true)
            }
//            print(realm.objects(Coin.self).map({ (c) -> String in
//                return c.name
//            }))
            self.fetchAllExchangesAndPairs(completion: completion)
            
            
            
        })
    }
    func fetchAllExchangesAndPairs(completion:  ( () -> Void)?) {
        bigService.fetchAllExchangesAndPairs(completion: { (json) in
            let realm = try! Realm()
            try! realm.write {
                for each in json.dictionaryValue {
                    let exchangeName = each.key
                    if exchangeName.lowercased() == "localbitcoins" {
                        continue
                    }
                    var exchange: Exchange
                    if let c = realm.object(ofType: Exchange.self, forPrimaryKey: exchangeName) {
                        exchange = c
                    } else {
                        exchange = Exchange()
                        exchange.name = exchangeName
                    }
                    
//                    realm.add(exchange, update: true)
//                    print(exchangeName)

                    for symbol in each.value.dictionaryValue {
                        var coinSymbol = symbol.key.lowercased()
//                        correct coin names
                        var base: Coin = Coin()
                        base.symbol = coinSymbol
                        if let c = realm.object(ofType: Coin.self, forPrimaryKey: coinSymbol) {
//                            print(c.name)
                            
                            
                            base = c
                            
                            print(base.nameAndSymbol)
                        } else {
                            realm.add(base, update: true)
                            
                        }
                        
                        
                        for quote in symbol.value.arrayValue {
                            
                            let quoteKey = quote.stringValue.lowercased()
                            
                            var quoteCoin: Coin = Coin()
//                            quoteCoin = Coin()
                            quoteCoin.symbol = quoteKey
                            if quoteCoin.symbol == "btc" && quoteCoin.name == "" {
                                
                                print("what")
                                
                            }
                            if let c = realm.object(ofType: Coin.self, forPrimaryKey: quoteKey) {
                                quoteCoin = c
                            }
                            
                            
                            var pair: Pair = Pair()
                            pair.setAll(base: base, quote: quoteCoin, exc: exchange)
                            if let c = realm.object(ofType: Pair.self, forPrimaryKey: pair.compoundKeyValue()) {
                                pair = c
                            } 
                            
                            
                            base.pairs.append(pair)
                            quoteCoin.quotes.append(pair)
                            exchange.pairs.append(pair)
                            
//                            print("\(pair.baseSymbol) ??? \(pair.quoteSymbol)")
                            realm.add(quoteCoin, update: true)
//                            print("quote")
//                            print(quoteCoin.nameAndSymbol)
                            if quoteCoin.symbol == "btc" && quoteCoin.name == "" {
                                print("what")
                            }
                            realm.add(pair, update: true)
                        }
                        
                        print(base.nameAndSymbol)
                        print("-----------------------")
                        
                    }
                    realm.add(exchange, update: true)
                    
                    
                }
            }
            if let c = completion {
                c()
//                print(realm.objects(Pair.self))
            }
            
        })
    }
    public static func pair(base: String, quote: String, exchange: String) -> Pair? {
        if base != "" && quote != "" && exchange != "" {
            let pk = "\(base.lowercased())-\(quote.lowercased())-\(exchange)"
            let realm = try! Realm()
            var pair: Pair? = realm.object(ofType: Pair.self, forPrimaryKey: pk)
            return pair
        } else {
            return nil
        }
        
//        let base = realm.objects(Coin.self).filter { (c) -> Bool in
//            if c.symbol == base {
//                print(c.symbol)
//                return true
//            } else {
//                return false
//            }
//        }
//        print(base.first!.pairs.count)
//        pair = base.first!.pairs.filter { (p) -> Bool in
////            print(p.exchangeName)
//            return p.exchangeName == exchange
//            if let exch = p.exchange {
////                if exch.name == exchange {
//                print(exch.name)
////                }
//                return exch.name == exchange
//            } else {
//                return false
//            }
////            return p.exchange!.name == exchange
//        }
////        base.pairs.index { (p) -> Bool in
////            return p.quote?.symbol == quote
////        }
//
//        if pair.count > 0 {
//            return pair.first!
//        } else {
//            return nil
//        }
        
        
    }
    
//    func retrieveCoins(completion:  ( ([Coin]) -> Void)?) {
////        self.fetchAllExchangesAndPairs()
//        self.exchangeInfoGroup.enter()
//        marketService.getCoinInfo(completion: { (json) in
//            MarketWorker.sharedInstance.topCoins = []
////            self.coins = []
////            let getExchangeInfoGroup = DispatchGroup()
//            for data in json {
//                let symbol = data.1["symbol"].string!.lowercased()
//                let cap = data.1["market_cap_usd"].string!
//                let price = Double(data.1["price_usd"].string!)!
//                let percent: Double
//                if let temp = data.1["percent_change_24h"].string {
//                    percent = Double(temp)!
//                } else {
//                    percent = 0.0
//                }
//                let coin = Coin(name: data.1["name"].string!, symbol: symbol)
//                MarketWorker.sharedInstance.coinCollection[coin.symbol.lowercased()] = coin
//
//                let defaultPair: Pair = Pair(base: coin.symbol, quote: "usd", pair: "\(coin.symbol)usd")
//                defaultPair.percentChange24 = percent
//                defaultPair.marketCap = Double(cap)
//                defaultPair.price = price
//                defaultPair.volume24 = Double(data.1["24h_volume_usd"].string!)
//
//                let cacher = MarketWorker.sharedInstance
//                cacher.pairs[coin.symbol] = [:]
//                cacher.pairs[coin.symbol]!["usd"] = defaultPair
//
//                let defaultName = "CoinMarketCap"
//
//                if cacher.exchanges["CoinMarketCap"] != nil {
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol] = [:]
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol]!["usd"] = cacher.pairs[coin.symbol]!["usd"]!
//                    cacher.exchanges["CoinMarketCap"]!.coins[coin.symbol] = cacher.coinCollection[coin.symbol]!
//                } else {
//                    cacher.exchanges["CoinMarketCap"] = Exchange(pairs: nil, name: "CoinMarketCap")
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol] = [:]
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol]!["usd"] = cacher.pairs[coin.symbol]!["usd"]!
//                    cacher.exchanges["CoinMarketCap"]!.coins[coin.symbol] = cacher.coinCollection[coin.symbol]!
//                }
//                cacher.pairs[coin.symbol]!["usd"]!.exchanges["CoinMarketCap"] = cacher.exchanges["CoinMarketCap"]!
//
//                cacher.coinCollection[coin.symbol]!.exchanges["CoinMarketCap"] = cacher.exchanges["CoinMarketCap"]!
//                cacher.coinCollection[coin.symbol]!.pairs["usd"] = cacher.pairs[coin.symbol]!["usd"]
//
//
//                MarketWorker.sharedInstance.topCoins.append(MarketWorker.sharedInstance.coinCollection[coin.symbol.lowercased()]!)
//
//            }
//            self.fetchAllExchangesAndPairs(completion: {
//                if let c = completion {
//                    c([])
//                }
//
//            })
//
//
//
//
//
//        })
//
//
//
//    }
    
    
    
//    func fetchAllExchangesAndPairs(completion:  ( () -> Void)?) {
////        self.exchangeInfoGroup.enter()
//        bigService.fetchAllExchangesAndPairs(completion:  {(json) in
//            var allCoins: [String] = []
//            for each in json.dictionaryValue {
////                print(each.key)
//                let exchangeName = each.key.lowercased()
//                if exchangeName == "localbitcoins" {
//                    continue
//                }
//                if self.exchanges[exchangeName] == nil {
//                    self.exchanges[exchangeName] = Exchange(pairs: [:], name: each.key)
//                }
////                var pairs: [String: [String: Pair]] = [:]
//                for symbol in each.value.dictionaryValue {
//                    allCoins.append(symbol.key)
//                    var coinName = symbol.key.lowercased()
//                    if self.coinMapper[coinName] != nil {
//                        coinName = self.coinMapper[coinName]!.lowercased()
//                    }
//                    if let coin = self.coinCollection[coinName] {
//
//
//                        for quote in symbol.value.arrayValue {
//                            let quoteKey = quote.stringValue.lowercased()
//                            let pair = Pair(base: coinName, quote: quoteKey, pair: "\(symbol)\(quote)")
//
//
//                            if self.pairs[coinName] != nil {
//                                if self.pairs[coinName]![quoteKey] != nil {
//                                    if self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] != nil {
//
//                                    } else {
//                                        self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                    }
//
//
//                                } else {
//                                    self.pairs[coinName]![quoteKey] = pair
//                                    self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                }
//                            } else {
//                                self.pairs[coinName] = [:]
//                                self.pairs[coinName]![quoteKey] = pair
//                                self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                            }
//                            if self.exchanges[exchangeName]!.pairs[coinName] != nil {
//
//                                if self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] != nil {
//
//                                } else {
//                                    self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] = self.pairs[coinName]![quoteKey]!
//                                }
//                            } else {
//                                self.exchanges[exchangeName]!.coins[coinName] = self.coinCollection[coinName]
//                                self.exchanges[exchangeName]!.pairs[coinName] = [:]
//                                self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] = self.pairs[coinName]![quoteKey]!
//                            }
//
//                            if self.coinCollection[coinName]!.exchanges[exchangeName] != nil {
//                                //                            self.coinCollection[symbol.key]!.exchanges[each.key]!.pairs
//
//                                self.coinCollection[coinName]!.pairs[quoteKey] = self.pairs[coinName]![quoteKey]!
//                            } else {
//                                self.coinCollection[coinName]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                self.coinCollection[coinName]!.pairs[quoteKey] = self.pairs[coinName]![quoteKey]!
//
//                            }
//
//
//
//                        }
//
//                    }
//
////                    print(self.coinCollection[coinName]!.exchanges[exchangeName]!.potentialPairs.count)
//
//                }
//            }
////            print(self.exchanges)
////            print(self.pairs)
////            print(self.coinCollection)
//
//            self.exchangeInfoGroup.leave()
//            if let c = completion {
//                c()
//            }
//
////            allCoins.index(of: "XMR")
//
//        })
//    }
    
    @objc func updateCoin() {
        print("updating")
        self.retrieveCoins(completion: nil)
    }
    
    static let sharedInstance: MarketWorker = MarketWorker()
    
    var refreshRate: TimeInterval = 300
    
    init() {
        
        
        
//        self.retrieveCoins(completion: { (d) in })
        
//        _ = Timer.scheduledTimer(timeInterval: self.refreshRate, target: self, selector: #selector(self.updateCoin), userInfo: nil, repeats: true)
        
    }
//    func saveCoins() throws {
//        let coins = Array(MarketWorker.sharedInstance.coinCollection.values)
//
//        var encoder = CerealEncoder()
//
//        let data = try CerealEncoder.data(withRoot: coins)
//
//        UserDefaults.standard.set(data, forKey: "coins")
//        UserDefaults.standard.synchronize()
//    }
//    func unpackCoins() throws {
//        if let data = UserDefaults.standard.data(forKey: "coins") {
//
//            let coins: [Coin] = try CerealDecoder.rootCerealItems(with: data)
//
//            for coin in coins {
//                self.coinCollection[coin.symbol] = coin
//            }
//        }
//
//    }
    
    var coinCollection: [String: Coin] = [:]
    var topCoins: Results<Coin> {
        get {
            let realm = try! Realm()
            let c = realm.objects(Coin.self)
//            print(c.map({ $0.name }))
            return c
        }
    }
    
    
    var exchanges: [String: Exchange] = [:]
    var pairs: [String: [String: Pair]] = [:]
    
    let coinMapper: [String: String] = [
        "iot": "miota",
//        "XBT": "BTC",
    ]
    
//    static let exchanges
}

