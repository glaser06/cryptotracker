//
//  MarketWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/23/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftyJSON
import Cereal
import RealmSwift

class MarketWorker
{
    let marketService = CoinMarketCapAPI()
    let exchangeService = CryptowatchAPI()
    let bigService = CryptocompareAPI()
    
    let exchangeInfoGroup = DispatchGroup()
    
    
    
    var lastUpdate: Date {
        get {
            let defaults = UserDefaults.standard
            if let d = defaults.object(forKey: "LastUpdateDate") {
                return d as! Date
            } else {
                
                return Date(timeIntervalSince1970: 20)
            }
//            return defaults.object(forKey: "LastUpdateDate")
        }
        set {
            let defaults = UserDefaults.standard
            defaults.set(newValue, forKey: "LastUpdateDate")
        }
    }
    
    func fetchCoinIDs(completion: (() -> Void)?) {
        let realm = try! Realm()
        bigService.fetchCoinList { (json) in
            let data = json.dictionaryValue["Data"]!.dictionaryValue
            try! realm.write {
                for each in data {
//                    print(each.value)
                    var coin = Coin()
                    let coinData = each.value.dictionaryValue
                    coin.setSymbol(sym: each.value.dictionaryValue["Symbol"]!.stringValue.lowercased())
                    coin.name = coinData["CoinName"]!.stringValue.lowercased()
                    if let u = realm.object(ofType: Coin.self, forPrimaryKey: coin.symbol) {
                        coin = u
                    }
                    coin.id = Int(coinData["Id"]!.stringValue)!
                    
                    realm.add(coin, update: true)
                    
                }
            }
            
            
            
            
        }
    }
    
    func retrieveCoins(completion: (() -> Void)?) {
        var realm = try! Realm()
        var usd: Coin = Coin()
        
        usd.name = "US Dollar".lowercased()
        usd.setSymbol(sym: "usd")
        var btc: Coin = Coin()
        btc.name = "bitcoin"
        btc.setSymbol(sym: "btc")


        if let u = realm.object(ofType: Coin.self, forPrimaryKey: "usd") {
            usd = u
        }
        if let u = realm.object(ofType: Coin.self, forPrimaryKey: "btc") {
            btc = u
        }
        
        
        marketService.getCoinInfo(completion: { (json) in
            realm = try! Realm()
            
            let coinmarketcap = Exchange()
            coinmarketcap.name = "CoinMarketCap"
            
            let cccagg = Exchange()
            cccagg.name = "CCCAGG"
            
            
            try! realm.write {
                realm.add(usd, update: true)
                realm.add(btc, update: true)
                realm.add(cccagg, update: true)
                realm.add(coinmarketcap, update: true)
                //                fix this
                
                for data in json {
                    let name: String = data.1["name"].stringValue.lowercased()
                    var symbol: String = data.1["symbol"].string!.lowercased()
                    if let s = self.coinMapper[symbol] {
                        symbol = s
                    }
                    let cap: Double = Double(data.1["market_cap_usd"].stringValue)!
                    let price: Double = Double(data.1["price_usd"].string!)!
                    let btcPrice: Double = Double(data.1["price_btc"].string!)!
                    let percent: Double
                    if let temp = data.1["percent_change_24h"].string {
                        percent = Double(temp)!
                    } else {
                        percent = 0.0
                    }
                    let volume = Double(data.1["24h_volume_usd"].stringValue)
                    
                    var coin: Coin = Coin()
                    coin.name = name
                    coin.setSymbol(sym: symbol)
                    if let c = realm.object(ofType: Coin.self, forPrimaryKey: symbol) {
                        coin = c
                        
                    } else {
                        realm.add(coin, update: true)
                    }
                    
                    
                    let usdPair = StorageManager.addPair(realm: realm, base: coin, quote: usd, exchange: coinmarketcap)
                    StorageManager.addPair(realm: realm, base: coin, quote: usd, exchange: cccagg)
                    
                    usdPair.price.value = price
                    usdPair.marketCap.value = cap
                    usdPair.volume.value = volume
                    usdPair.percentChange.value = percent
                    if coin.symbol != "btc" {
                        let btcPair = StorageManager.addPair(realm: realm, base: coin, quote: btc, exchange: coinmarketcap)
                        StorageManager.addPair(realm: realm, base: coin, quote: btc, exchange: cccagg)
                        btcPair.price.value = btcPrice
                        //                        usdPair.marketCap.value = cap
                        //                        usdPair.volume.value = volume
                        btcPair.percentChange.value = percent
                        
                    }
                    
                    //                    let addPair: (Coin, Coin, Exchange) -> Void = { (base, quote, exc) in
                    //                        var pair = Pair()
                    //
                    //                        pair.setAll(base: base, quote: quote, exc: coinmarketcap)
                    //                        if let p = base.defaultPair {
                    //                            pair = p
                    //                        } else {
                    //                            base.pairs.append(pair)
                    //                            realm.add(pair, update: true)
                    //                        }
                    //
                    //                        pair.price.value = price
                    //                        pair.marketCap.value = cap
                    //                        pair.volume.value = volume
                    //                        pair.percentChange.value = percent
                    //
                    //                        quote.quotes.append(pair)
                    //                        exc.pairs.append(pair)
                    //                    }
                    
                    
                    
                }
                
                realm.add(coinmarketcap, update: true)
            }
            
            
//            print(realm.objects(Coin.self).map({ (c) -> String in
//                return c.name
//            }))
            if let c = completion {
                c()
            }
//            self.fetchAllExchangesAndPairs(completion: nil)
            
            
            
        })
    }
    
    func fetchAllExchangesAndPairs(completion:  ( () -> Void)?) {
        
        bigService.fetchAllExchangesAndPairs(completion: { (json) in
            let realm = try! Realm()
            try! realm.write {
                for each in json.dictionaryValue {
                    let exchangeName = each.key
                    if exchangeName.lowercased() == "localbitcoins" {
                        continue
                    }
                    var exchange: Exchange
                    if let c = realm.object(ofType: Exchange.self, forPrimaryKey: exchangeName) {
                        exchange = c
                    } else {
                        exchange = Exchange()
                        exchange.name = exchangeName
                    }
                    realm.add(exchange, update: true)
//                    realm.add(exchange, update: true)
//                    print(exchangeName)

                    for symbol in each.value.dictionaryValue {
                        var coinSymbol = symbol.key.lowercased()
//                        correct coin names
                        var base: Coin = Coin()

                        base.setSymbol(sym: coinSymbol)
                        if let c = realm.object(ofType: Coin.self, forPrimaryKey: coinSymbol) {
//                            print(c.name)
                            
                            
                            base = c
                            
//                            print(base.nameAndSymbol)
                        } else {
                            realm.add(base, update: true)
                            
                        }
                        
                        
                        for quote in symbol.value.arrayValue {
                            
                            let quoteKey = quote.stringValue.lowercased()
                            
                            var quoteCoin: Coin = Coin()
//                            quoteCoin = Coin()

                            quoteCoin.setSymbol(sym: quoteKey)
                            
                            if let c = realm.object(ofType: Coin.self, forPrimaryKey: quoteKey) {
                                quoteCoin = c
                            } else {
                                realm.add(quoteCoin, update: true)
                            }
                            var pair: Pair = StorageManager.addPair(realm: realm, base: base, quote: quoteCoin, exchange: exchange)
                            
//                            var pair: Pair = Pair()
//                            pair.setAll(base: base, quote: quoteCoin, exc: exchange)
//                            if let c = realm.object(ofType: Pair.self, forPrimaryKey: pair.compoundKeyValue()) {
//                                pair = c
//                            }
//
//
//                            base.pairs.append(pair)
//                            quoteCoin.quotes.append(pair)
//                            exchange.pairs.append(pair)
//
////                            print("\(pair.baseSymbol) ??? \(pair.quoteSymbol)")
//
////                            print("quote")
//
//                            if quoteCoin.symbol == "btc" && quoteCoin.name == "" {
//                                print(quoteCoin.nameAndSymbol)
//                                print("what")
//                            }
//                            realm.add(pair, update: true)
                        }
                        
                        
                        
                    }
                    
                    
                    
                }
            }
            if let c = completion {
                c()
//                print(realm.objects(Pair.self))
            }
            
        })
    }
    public static func pair(base: String, quote: String, exchange: String) -> Pair? {
        if base != "" && quote != "" && exchange != "" {
            let pk = "\(base.lowercased())-\(quote.lowercased())-\(exchange)"
            let realm = try! Realm()
            var pair: Pair? = realm.object(ofType: Pair.self, forPrimaryKey: pk)
            return pair
        } else {
            return nil
        }
        
//        let base = realm.objects(Coin.self).filter { (c) -> Bool in
//            if c.symbol == base {
//                print(c.symbol)
//                return true
//            } else {
//                return false
//            }
//        }
//        print(base.first!.pairs.count)
//        pair = base.first!.pairs.filter { (p) -> Bool in
////            print(p.exchangeName)
//            return p.exchangeName == exchange
//            if let exch = p.exchange {
////                if exch.name == exchange {
//                print(exch.name)
////                }
//                return exch.name == exchange
//            } else {
//                return false
//            }
////            return p.exchange!.name == exchange
//        }
////        base.pairs.index { (p) -> Bool in
////            return p.quote?.symbol == quote
////        }
//
//        if pair.count > 0 {
//            return pair.first!
//        } else {
//            return nil
//        }
        
        
    }
    
//    func retrieveCoins(completion:  ( ([Coin]) -> Void)?) {
////        self.fetchAllExchangesAndPairs()
//        self.exchangeInfoGroup.enter()
//        marketService.getCoinInfo(completion: { (json) in
//            MarketWorker.sharedInstance.topCoins = []
////            self.coins = []
////            let getExchangeInfoGroup = DispatchGroup()
//            for data in json {
//                let symbol = data.1["symbol"].string!.lowercased()
//                let cap = data.1["market_cap_usd"].string!
//                let price = Double(data.1["price_usd"].string!)!
//                let percent: Double
//                if let temp = data.1["percent_change_24h"].string {
//                    percent = Double(temp)!
//                } else {
//                    percent = 0.0
//                }
//                let coin = Coin(name: data.1["name"].string!, symbol: symbol)
//                MarketWorker.sharedInstance.coinCollection[coin.symbol.lowercased()] = coin
//
//                let defaultPair: Pair = Pair(base: coin.symbol, quote: "usd", pair: "\(coin.symbol)usd")
//                defaultPair.percentChange24 = percent
//                defaultPair.marketCap = Double(cap)
//                defaultPair.price = price
//                defaultPair.volume24 = Double(data.1["24h_volume_usd"].string!)
//
//                let cacher = MarketWorker.sharedInstance
//                cacher.pairs[coin.symbol] = [:]
//                cacher.pairs[coin.symbol]!["usd"] = defaultPair
//
//                let defaultName = "CoinMarketCap"
//
//                if cacher.exchanges["CoinMarketCap"] != nil {
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol] = [:]
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol]!["usd"] = cacher.pairs[coin.symbol]!["usd"]!
//                    cacher.exchanges["CoinMarketCap"]!.coins[coin.symbol] = cacher.coinCollection[coin.symbol]!
//                } else {
//                    cacher.exchanges["CoinMarketCap"] = Exchange(pairs: nil, name: "CoinMarketCap")
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol] = [:]
//                    cacher.exchanges["CoinMarketCap"]!.pairs[coin.symbol]!["usd"] = cacher.pairs[coin.symbol]!["usd"]!
//                    cacher.exchanges["CoinMarketCap"]!.coins[coin.symbol] = cacher.coinCollection[coin.symbol]!
//                }
//                cacher.pairs[coin.symbol]!["usd"]!.exchanges["CoinMarketCap"] = cacher.exchanges["CoinMarketCap"]!
//
//                cacher.coinCollection[coin.symbol]!.exchanges["CoinMarketCap"] = cacher.exchanges["CoinMarketCap"]!
//                cacher.coinCollection[coin.symbol]!.pairs["usd"] = cacher.pairs[coin.symbol]!["usd"]
//
//
//                MarketWorker.sharedInstance.topCoins.append(MarketWorker.sharedInstance.coinCollection[coin.symbol.lowercased()]!)
//
//            }
//            self.fetchAllExchangesAndPairs(completion: {
//                if let c = completion {
//                    c([])
//                }
//
//            })
//
//
//
//
//
//        })
//
//
//
//    }
    
    
    
//    func fetchAllExchangesAndPairs(completion:  ( () -> Void)?) {
////        self.exchangeInfoGroup.enter()
//        bigService.fetchAllExchangesAndPairs(completion:  {(json) in
//            var allCoins: [String] = []
//            for each in json.dictionaryValue {
////                print(each.key)
//                let exchangeName = each.key.lowercased()
//                if exchangeName == "localbitcoins" {
//                    continue
//                }
//                if self.exchanges[exchangeName] == nil {
//                    self.exchanges[exchangeName] = Exchange(pairs: [:], name: each.key)
//                }
////                var pairs: [String: [String: Pair]] = [:]
//                for symbol in each.value.dictionaryValue {
//                    allCoins.append(symbol.key)
//                    var coinName = symbol.key.lowercased()
//                    if self.coinMapper[coinName] != nil {
//                        coinName = self.coinMapper[coinName]!.lowercased()
//                    }
//                    if let coin = self.coinCollection[coinName] {
//
//
//                        for quote in symbol.value.arrayValue {
//                            let quoteKey = quote.stringValue.lowercased()
//                            let pair = Pair(base: coinName, quote: quoteKey, pair: "\(symbol)\(quote)")
//
//
//                            if self.pairs[coinName] != nil {
//                                if self.pairs[coinName]![quoteKey] != nil {
//                                    if self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] != nil {
//
//                                    } else {
//                                        self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                    }
//
//
//                                } else {
//                                    self.pairs[coinName]![quoteKey] = pair
//                                    self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                }
//                            } else {
//                                self.pairs[coinName] = [:]
//                                self.pairs[coinName]![quoteKey] = pair
//                                self.pairs[coinName]![quoteKey]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                            }
//                            if self.exchanges[exchangeName]!.pairs[coinName] != nil {
//
//                                if self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] != nil {
//
//                                } else {
//                                    self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] = self.pairs[coinName]![quoteKey]!
//                                }
//                            } else {
//                                self.exchanges[exchangeName]!.coins[coinName] = self.coinCollection[coinName]
//                                self.exchanges[exchangeName]!.pairs[coinName] = [:]
//                                self.exchanges[exchangeName]!.pairs[coinName]![quoteKey] = self.pairs[coinName]![quoteKey]!
//                            }
//
//                            if self.coinCollection[coinName]!.exchanges[exchangeName] != nil {
//                                //                            self.coinCollection[symbol.key]!.exchanges[each.key]!.pairs
//
//                                self.coinCollection[coinName]!.pairs[quoteKey] = self.pairs[coinName]![quoteKey]!
//                            } else {
//                                self.coinCollection[coinName]!.exchanges[exchangeName] = self.exchanges[exchangeName]!
//                                self.coinCollection[coinName]!.pairs[quoteKey] = self.pairs[coinName]![quoteKey]!
//
//                            }
//
//
//
//                        }
//
//                    }
//
////                    print(self.coinCollection[coinName]!.exchanges[exchangeName]!.potentialPairs.count)
//
//                }
//            }
////            print(self.exchanges)
////            print(self.pairs)
////            print(self.coinCollection)
//
//            self.exchangeInfoGroup.leave()
//            if let c = completion {
//                c()
//            }
//
////            allCoins.index(of: "XMR")
//
//        })
//    }
    
    @objc func updateCoin() {
        print("updating")
        self.retrieveCoins(completion: nil)
    }
    
    static let sharedInstance: MarketWorker = MarketWorker()
    
    var refreshRate: TimeInterval = 300
    
    init() {
        
        
        
        
//        self.retrieveCoins(completion: { (d) in })
        
//        _ = Timer.scheduledTimer(timeInterval: self.refreshRate, target: self, selector: #selector(self.updateCoin), userInfo: nil, repeats: true)
        
    }
    func setup() {
        realm = try! Realm()
        self.topCoins = realm.objects(Coin.self).filter("ANY pairs.exchangeName = %@", "CoinMarketCap")
        print(self.lastUpdate.timeIntervalSinceNow)
        if self.lastUpdate.timeIntervalSinceNow < -300000 {
            CodeTimer.set()
            self.retrieveCoins(completion: {
                DispatchQueue.global(qos: .background).async {
                    self.fetchAllExchangesAndPairs(completion: {
                        
                        let end = Date()
//                        let interval = end.timeIntervalSince(start)
                        CodeTimer.finish("finished setup")
                        MarketWorker.sharedInstance.lastUpdate = end
                    })
                }
                
            })
            MarketWorker.sharedInstance.fetchCoinIDs(completion: nil)
        }
//        realm.objects(Coin.self).filter { (coin) -> Bool in
//            //            return coin.defaultPair != nil
//            coin.defaultPair == nil
//            }
    }
//    func saveCoins() throws {
//        let coins = Array(MarketWorker.sharedInstance.coinCollection.values)
//
//        var encoder = CerealEncoder()
//
//        let data = try CerealEncoder.data(withRoot: coins)
//
//        UserDefaults.standard.set(data, forKey: "coins")
//        UserDefaults.standard.synchronize()
//    }
//    func unpackCoins() throws {
//        if let data = UserDefaults.standard.data(forKey: "coins") {
//
//            let coins: [Coin] = try CerealDecoder.rootCerealItems(with: data)
//
//            for coin in coins {
//                self.coinCollection[coin.symbol] = coin
//            }
//        }
//
//    }
    
    var coinCollection: [String: Coin] = [:]
    var realm: Realm!
    
    var topCoins: Results<Coin>?

//        get {
//            let realm = try! Realm()
//            let c = realm.objects(Coin.self).filter { (coin) -> Bool in
//                return coin.defaultPair != nil
//            }
////            print(c.map({ $0.name }))
//            return c
//        }
//    }

    
    var exchanges: [String: Exchange] = [:]
    var pairs: [String: [String: Pair]] = [:]
    
    let coinMapper: [String: String] = [
        "miota": "iot",
//        "XBT": "BTC",
    ]
    
    
//    static let exchanges
}

