//
//  MarketWorker.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/23/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SwiftyJSON
import Cereal

class MarketWorker
{
    let marketService = CoinMarketCapAPI()
    let exchangeService = CryptowatchAPI()
    
    let exchangeInfoGroup = DispatchGroup()
    
    func retrieveCoins(completion: @escaping ([Coin]) -> Void) {
        marketService.getCoinInfo(completion: { (json) in
            var responseCoins: [ListCoins.FetchCoins.Response.Coin] = []
//            self.coins = []
//            let getExchangeInfoGroup = DispatchGroup()
            for data in json {
                let symbol = data.1["symbol"].string!.lowercased()
                let cap = data.1["market_cap_usd"].string!
                let price = Double(data.1["price_usd"].string!)!
                let percent: Double
                if let temp = data.1["percent_change_24h"].string {
                    percent = Double(temp)!
                } else {
                    percent = 0.0
                }
                let coin = Coin(name: data.1["name"].string!, symbol: symbol)
                
                var defaultPair: Pair = Pair(base: coin, quote: "usd", pair: "\(coin.symbol)usd")
                defaultPair.percentChange24 = percent
                defaultPair.marketCap = Double(cap)
                defaultPair.price = price
                defaultPair.volume24 = Double(data.1["24h_volume_usd"].string!)
                
                var tempDict: [String: [String:Pair]] = [:]
                tempDict[coin.symbol] = [:]
                tempDict[coin.symbol]!["usd"] = defaultPair
                let defaultExchange = Exchange(pairs: tempDict, name: "CoinMarketCap")
                coin.exchanges["CoinMarketCap"] = defaultExchange
                
                let cw = CoinWorker()
//                print(coin.symbol)
                MarketWorker.sharedInstance.coinCollection[coin.symbol.lowercased()] = coin
                
//                MarketWorker.sharedInstance.exchangeInfoGroup.enter()
//                cw.fetchExchanges(coin: coin, completion: { (newCoin) in
////                    self.coins.append(newCoin)
//                    MarketWorker.sharedInstance.coinCollection[newCoin.name] = newCoin
//                    MarketWorker.sharedInstance.exchangeInfoGroup.leave()
//                }, error: {
//                    MarketWorker.sharedInstance.exchangeInfoGroup.leave()
//                })
                
                
                //                print(data.1["symbol"].string!)
                //                print(data.1["market_cap_usd"].string!)
                //                print(Double(data.1["price_usd"].string!)!)
                //                print(Double(data.1["percent_change_24h"].string!)!)
//                let tempCoin = ListCoins.FetchCoins.Response.Coin(symbol: symbol, cap: cap, price: price, percentage: percent)
//                responseCoins.append(tempCoin)
                
            }
            self.exchangeInfoGroup.enter()
            self.exchangeService.fetchAllExchangesAndPairs(completion: { (json) in
                
                let results = json["result"]
                for market in results.dictionaryValue {
                    let exchangeName: String = market.key.components(separatedBy: ":")[0]
                    let pairName: String = market.key.components(separatedBy: ":")[1]
                    let quoteName: String = pairName.substring(from:pairName.index(pairName.endIndex, offsetBy: -3))
                    let baseName: String = pairName.components(separatedBy: quoteName)[0]
//                    print(quoteName)
//                    print(exchangeName)
//                    print(pairName)
                    
                    if MarketWorker.sharedInstance.coinCollection[baseName] != nil {
                        let p = Pair(base: MarketWorker.sharedInstance.coinCollection[baseName]!, quote: quoteName, pair: pairName)
                        if MarketWorker.sharedInstance.exchanges[exchangeName] != nil {
                            if MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName] == nil {
                                MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName] = [:]
//                                let p = Pair(base: MarketWorker.sharedInstance.coinCollection[baseName]!, quote: quoteName, pair: pairName)
                                MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName] = p
                                
                                
                            }
                            
                            //                            MarketWorker.sharedInstance.coinCollection[baseName]
                            
                            
                            
                        } else {
                            MarketWorker.sharedInstance.exchanges[exchangeName] = Exchange(pairs: [:], name: exchangeName)
                            if MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName] == nil {
                                MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName] = [:]
                                
                                MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName] = p
                                
                                
                            }
                            
                            
//                            MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]!.lowPrice24 = market.value["price"]["low"].doubleValue
//                            MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]!.highPrice24 = market.value["price"]["high"].doubleValue
//                            MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]!.percentChange24 = market.value["price"]["change"]["percentage"].doubleValue
//                            MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]!.price = market.value["price"]["last"].doubleValue
//                            MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]!.volume24 = market.value["volume"].doubleValue
                        }
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName] = p
                        
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName]!.lowPrice24 = market.value["price"]["low"].doubleValue
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName]!.highPrice24 = market.value["price"]["high"].doubleValue
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName]!.percentChange24 = market.value["price"]["change"]["percentage"].doubleValue
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName]!.price = market.value["price"]["last"].doubleValue
                        MarketWorker.sharedInstance.exchanges[exchangeName]!.pairs[baseName]![quoteName]!.volume24 = market.value["volume"].doubleValue
                        
                        MarketWorker.sharedInstance.coinCollection[baseName]?.exchanges[exchangeName] = MarketWorker.sharedInstance.exchanges[exchangeName]
                    }
                    
                    
//                    MarketWorker.sharedInstance.exchanges[exchangeName] =
                    
                    
                    
                }
                completion([])
                do  {
                    try self.saveCoins()
                } catch {
                    
                }
                self.exchangeInfoGroup.leave()
                
                
                
                
                
            })
            
            
//            MarketWorker.sharedInstance.exchangeInfoGroup.notify(queue: .main, execute: {
//                
//                let exchanges: [Coin] = Array(MarketWorker.sharedInstance.coinCollection.values).sorted(by: { (coin1,coin2) in
//                    return coin1.exchanges["CoinMarketCap"]!.pairs.first!.price! > coin2.exchanges["CoinMarketCap"]!.pairs.first!.price!
//                })
//                completion(exchanges)
//            })
            
        })
        
        
        
    }
    
    static let sharedInstance: MarketWorker = MarketWorker()
    
    init() {
        do {
            try self.unpackCoins()
        } catch {
            
        }
        
    }
    func saveCoins() throws {
        let coins = Array(MarketWorker.sharedInstance.coinCollection.values)
        print(coins.count)
        var encoder = CerealEncoder()
        
        let data = try CerealEncoder.data(withRoot: coins)
//        let decoder = try CerealDecoder(data: data)
        
//        let coins1: [Coin] = try CerealDecoder.rootCerealItems(with: data)
//        print(coins1.count)
        UserDefaults.standard.set(data, forKey: "coins")
        UserDefaults.standard.synchronize()
    }
    func unpackCoins() throws {
        if let data = UserDefaults.standard.data(forKey: "coins") {
//            let decoder = try CerealDecoder(data: data)
            let coins: [Coin] = try CerealDecoder.rootCerealItems(with: data)
//            let coins: [Coin] = try decoder.decodeIdentifyingCerealArray(key: "coins")?.CER_casted() ?? []
            for coin in coins {
                self.coinCollection[coin.symbol] = coin
            }
        }
        
    }
    
    var coinCollection: [String: Coin] = [:]
    var exchanges: [String: Exchange] = [:]
    
//    static let exchanges
}

