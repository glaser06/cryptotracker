//
//  ListCoinsInteractor.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/23/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RealmSwift

protocol ListCoinsBusinessLogic
{

    func fetchCoins(request: ListCoins.FetchCoins.Request)
    func forceRefresh(request: ListCoins.FetchCoins.Request)
    func searchCoin(request: ListCoins.SearchCoin.Request)
    
    
}

protocol ListCoinsDataStore
{
    //var name: String { get set }
    var coins: Results<Coin>? { get set }
    var gotoTransaction: Bool? { get set }
    var doSwitch: Bool? { get set }
}

class ListCoinsInteractor: ListCoinsBusinessLogic, ListCoinsDataStore
{
    var presenter: ListCoinsPresentationLogic?
    var worker: ListCoinsWorker?
    var marketWorker: MarketWorker = MarketWorker.sharedInstance
    
    // MARK: Do something
    var coins: Results<Coin>?
    var gotoTransaction: Bool?
    var doSwitch: Bool?
    
    func searchCoin(request: ListCoins.SearchCoin.Request) {
        let query = request.query
        
        let results = self.coins?.filter("symbol CONTAINS %@ || name CONTAINS %@", query.lowercased(), query.lowercased())

//        let results = self.coins.filter({
//            $0.symbol.lowercased().range(of: query.lowercased()) != nil
//        })
        
        let resp = ListCoins.SearchCoin.Response(coins: results!.map({
            let cmc = $0.pair(with: "usd", on: "CoinMarketCap")
            return ListCoins.SearchCoin.Response.Coin(name: $0.name, symbol: $0.symbol.uppercased(), cap: cmc?.marketCapString ?? "", price: cmc?.price.value ?? 0.0, percentage: cmc?.percentChange.value ?? 0.0)
        }))
        self.presenter?.presentResults(response: resp)
        
    }
    
    func forceRefresh(request: ListCoins.FetchCoins.Request) {
        marketWorker.retrieveCoins(completion: {(c) in
            self.fetchCoins(request: request)
        }, error: {
            self.fetchCoins(request: request)
        })

    }
    
    func fetchCoins(request: ListCoins.FetchCoins.Request) {
        let coins1: Results<Coin> = MarketWorker.sharedInstance.topCoins!
        
        //            completion(exchanges)
        self.coins = coins1
        var responseCoins: [ListCoins.FetchCoins.Response.Coin] = []
        
        let start = Date()
        
        var a = coins1.filter({ (coin) -> Bool in
            return coin.defaultPair != nil
            })
        var b = a.sorted(by: { (c1, c2) -> Bool in
                let m1 = c1.pair(with: "usd", on: "CoinMarketCap")!
                let m2 = c2.pair(with: "usd", on: "CoinMarketCap")!
                return m1.marketCap.value! > m2.marketCap.value!
            }).map { (coin) -> ListCoins.FetchCoins.Response.Coin in
                var statPair: Pair = coin.pair(with: "usd", on: "CoinMarketCap")!
                
                let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: statPair.marketCapString, price: statPair.price.value ?? 0.0, percentage: statPair.percentChange.value ?? 0.0)
                return tempCoin
            }
        responseCoins = b
        let end = Date()
        let interval = end.timeIntervalSince(start)
        print(interval)
//        coins.map { (coin) -> U in
//            var statPair: Pair
//            if let pair = coin.defaultPair  {
//                statPair = pair
//                let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: String(describing: Int(statPair.marketCap.value!)), price: statPair.price.value!, percentage: statPair.percentChange.value!)
//            } else {
//                continue
//            }
        
            
            
        
//        for coin in coins {
//            var statPair: Pair
//            if let pair = coin.defaultPair  {
//                statPair = pair
//            } else {
//                continue
//            }
//
//
//            let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: String(describing: Int(statPair.marketCap.value!)), price: statPair.price.value!, percentage: statPair.percentChange.value!)
//            responseCoins.append(tempCoin)
//        }
        self.presenter?.presentCoins(response: ListCoins.FetchCoins.Response(coins: responseCoins, gotoTransaction: self.gotoTransaction ?? false, doSwitch: self.doSwitch ?? true))
        request.completion()

        
    }
}
