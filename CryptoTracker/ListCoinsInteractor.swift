//
//  ListCoinsInteractor.swift
//  CryptoTracker
//
//  Created by Zaizen Kaegyoshi on 8/23/17.
//  Copyright (c) 2017 zaizencorp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RealmSwift

protocol ListCoinsBusinessLogic
{

    func fetchCoins(request: ListCoins.FetchCoins.Request)
    func forceRefresh(request: ListCoins.FetchCoins.Request)
    func searchCoin(request: ListCoins.SearchCoin.Request)
    
    
}

protocol ListCoinsDataStore
{
    //var name: String { get set }
    var coins: Results<Coin>? { get set }
    var gotoTransaction: Bool? { get set }
    var doSwitch: Bool? { get set }
}

class ListCoinsInteractor: ListCoinsBusinessLogic, ListCoinsDataStore
{
    var presenter: ListCoinsPresentationLogic?
    var worker: ListCoinsWorker?
    var marketWorker: MarketWorker = MarketWorker.sharedInstance
    
    // MARK: Do something
    var coins: Results<Coin>?
    var gotoTransaction: Bool?
    var doSwitch: Bool?
    
    func searchCoin(request: ListCoins.SearchCoin.Request) {
        let query = request.query
        
        let results = self.coins?.filter("symbol CONTAINS %@ || name CONTAINS %@", query.lowercased(), query.lowercased())

//        let results = self.coins.filter({
//            $0.symbol.lowercased().range(of: query.lowercased()) != nil
//        })
        
        let resp = ListCoins.SearchCoin.Response(coins: results!.map({
            ListCoins.SearchCoin.Response.Coin(name: $0.name, symbol: $0.symbol.uppercased(), cap: $0.defaultPair!.marketCapString, price: $0.defaultPair!.price.value!, percentage: $0.defaultPair!.percentChange.value!)
        }))
        self.presenter?.presentResults(response: resp)
        
    }
    
    func forceRefresh(request: ListCoins.FetchCoins.Request) {
        marketWorker.retrieveCoins(completion: {(c) in
            self.fetchCoins(request: request)
        })

    }
    
    func fetchCoins(request: ListCoins.FetchCoins.Request) {
        let coins: Results<Coin> = MarketWorker.sharedInstance.topCoins!
        
        //            completion(exchanges)
        self.coins = coins
        var responseCoins: [ListCoins.FetchCoins.Response.Coin] = []
        print(coins.count)
        let start = Date()
        responseCoins = coins.filter { (coin) -> Bool in
            return coin.defaultPair != nil
            }.map { (coin) -> ListCoins.FetchCoins.Response.Coin in
                var statPair: Pair = coin.defaultPair!
                let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: String(describing: Int(statPair.marketCap.value!)), price: statPair.price.value!, percentage: statPair.percentChange.value!)
                return tempCoin
        }
        let end = Date()
        let interval = end.timeIntervalSince(start)
        print(interval)
//        coins.map { (coin) -> U in
//            var statPair: Pair
//            if let pair = coin.defaultPair  {
//                statPair = pair
//                let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: String(describing: Int(statPair.marketCap.value!)), price: statPair.price.value!, percentage: statPair.percentChange.value!)
//            } else {
//                continue
//            }
        
            
            
        
//        for coin in coins {
//            var statPair: Pair
//            if let pair = coin.defaultPair  {
//                statPair = pair
//            } else {
//                continue
//            }
//
//
//            let tempCoin = ListCoins.FetchCoins.Response.Coin(name: coin.name, symbol: coin.symbol, cap: String(describing: Int(statPair.marketCap.value!)), price: statPair.price.value!, percentage: statPair.percentChange.value!)
//            responseCoins.append(tempCoin)
//        }
        self.presenter?.presentCoins(response: ListCoins.FetchCoins.Response(coins: responseCoins, gotoTransaction: self.gotoTransaction ?? false, doSwitch: self.doSwitch ?? true))
        request.completion()
//        MarketWorker.sharedInstance.retrieveCoins {
//
//        }
        
        
//        marketWorker.retrieveCoins(completion: { (coins) in
        
            
            
            
//            for data in json {
//                let symbol = data.1["symbol"].string!
//                let cap = data.1["market_cap_usd"].string!
//                let price = Double(data.1["price_usd"].string!)!
//                let percent: Double
//                if let temp = data.1["percent_change_24h"].string {
//                    percent = Double(temp)!
//                } else {
//                    percent = 0.0
//                }
//                let coin = Coin(name: data.1["name"].string!, symbol: symbol)
//                
//                var defaultPair: Pair = Pair(base: coin, quote: "usd", pair: "\(coin.symbol)usd")
//                defaultPair.percentChange24 = percent
//                defaultPair.marketCap = Double(cap)
//                defaultPair.price = price
//                defaultPair.volume24 = Double(data.1["24h_volume_usd"].string!)
//                let defaultExchange = Exchange(pairs: [defaultPair], name: "CoinMarketCap")
//                coin.exchanges["CoinMarketCap"] = defaultExchange
////                coin.overallInfo = Coin.OverallStatistics(marketCap: Double(cap), price: price, percentChange24: percent, valueChange24: nil, percentChange7D: nil, valueChange7D: nil, supply: nil, volume24: Double(data.1["24h_volume_usd"].string!))
////                var usd = Coin(name: "USD", symbol: "USD")
////                var pair = Pair(base: coin, quote: "usd", pair: "\(symbol)usd")
//////                price: price, percentChange24: nil, valueChange24: nil, volume24: nil, lastPrice: nil, highPrice24: nil, lowPrice24: nil)
////                pair.price = price
////                var exchange = Exchange(pairs: [pair], name: "Bitfinex")
////                coin.exchanges["bitfinex"] = exchange
////                let cw = CoinWorker()
//                self.coins.append(coin)
////                MarketWorker.sharedInstance.coinCollection[coin.symbol] = coin
////                cw.fetchExchanges(coin: coin, completion: { (newCoin) in
////                    self.coins.append(newCoin)
////                    MarketWorker.sharedInstance.coinCollection[newCoin.name] = newCoin
////                }, error: {
////                    
////                })
//                
//                
////                print(data.1["symbol"].string!)
////                print(data.1["market_cap_usd"].string!)
////                print(Double(data.1["price_usd"].string!)!)
////                print(Double(data.1["percent_change_24h"].string!)!)
//                let tempCoin = ListCoins.FetchCoins.Response.Coin(symbol: symbol, cap: cap, price: price, percentage: percent)
//                responseCoins.append(tempCoin)
//            }
            
            
//        })
        
    }
}
